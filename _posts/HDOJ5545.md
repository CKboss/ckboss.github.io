title: HDOJ 5545 The Battle of Guandu 最短路

date: 2015-11-04 14:00:44

tags:
- spfa
- 想法技巧

categories:
- acm_图论

---

对于每个村庄,会对一个战场x增加一个士兵对另一个战场y减少一个士兵.
士兵总体数量是守恒的,我们可以连一条 $x \longrightarrow y$ 权值为c的边.

然后以重要程度为0的战场为源点,统计重要成都为2的战场的值.

# [The Battle of Guandu](http://acm.hdu.edu.cn/showproblem.php?pid=5545)

Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 65535/65535 K (Java/Others)
Total Submission(s): 20    Accepted Submission(s): 10


##### Problem Description
In the year of 200, two generals whose names are Cao Cao and Shao Yuan are fighting in Guandu. The battle of Guandu was a great battle and the two armies were fighting at M different battlefields whose numbers were 1 to M. There were also N villages nearby numbered from 1 to N. Cao Cao could train some warriors from those villages to strengthen his military. For village i, Cao Cao could only call for some number of warriors join the battlefield xi. However, Shao Yuan's power was extremely strong at that time. So in order to protect themselves, village i would also send equal number of warriors to battlefield yi and join the Yuan Shao's Army. If Cao Cao had called for one warrior from village i, he would have to pay ci units of money for the village. There was no need for Cao Cao to pay for the warriors who would join Shao Yuan's army. At the beginning, there were no warriors of both sides in every battlefield.

As one of greatest strategist at that time, Cao Cao was considering how to beat Shao Yuan. As we can image, the battlefields would have different level of importance wi. Some of the battlefields with wi=2 were very important, so Cao Cao had to guarantee that in these battlefields, the number of his warriors was greater than Shao Yuan's. And some of the battlefields with wi=1 were not as important as before, so Cao Cao had to make sure that the number of his warriors was greater or equal to Shao Yuan's. The other battlefields with wi=0 had no importance, so there were no restriction about the number of warriors in those battlefields. Now, given such conditions, could you help Cao Cao find the least number of money he had to pay to win the battlefield?
 

##### Input
The first line of the input gives the number of test cases, T(1≤T≤30). T test cases follow.

Each test case begins with two integers N and M(1≤N,M≤105) in one line.

The second line contains N integers separated by blanks. The ith integer xi(1≤xi≤M) means Cao Cao could call for warriors from village i to battlefield xi.

The third line also contains N integers separated by blanks. The ith integer yi(1≤yi≤M) means if Cao Cao called some number of warriors from village i, there would be the same number of warriors join Shao Yuan's army and fight in battlefield yi.

The next line contains N integers separated by blanks. The ith integer ci(0≤ci≤105) means the number of money Cao Cao had to pay for each warrior from this village.

The last line contains M integers separated by blanks. The ith number wi(wi∈0,1,2) means the importance level of ith battlefield.
 

##### Output
For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the least amount of money that Cao Cao had to pay for all the warriors to win the battle. If he couldn't win, y=−1.

```
Sample Input
2
2 3
2 3
1 1
1 1
0 1 2
1 1
1
1
1
2
 

Sample Output
Case #1: 1
Case #2: -1
```

Source
The 2015 China Collegiate Programming Contest

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月04日 星期三 11时17分31秒
File Name     :HDOJ5545.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;
const int maxn=100100;
const LL INF=1LL<<61;

struct Edge
{
    int to,next,cost;
}edge[maxn];

int Adj[maxn],Size;

void init()
{
    memset(Adj,-1,sizeof(Adj)); Size=0;
}

void Add_Edge(int u,int v,int c)
{
    edge[Size].to=v;
    edge[Size].next=Adj[u];
    edge[Size].cost=c;
    Adj[u]=Size++;
}

/// number of village and battlefield
int n,m;
int c[maxn],x[maxn],y[maxn];
int w[maxn];

/*************** spfa ******************/

LL dist[maxn];
bool inq[maxn];

void spfa()
{
    /// init
    queue<int> q;
    for(int i=1;i<=m;i++)
    {
        if(w[i]==0)
        {
            dist[i]=0;
            q.push(i);
            inq[i]=true;
        }
        else
        {
            dist[i]=INF;
            inq[i]=false;
        }
    }

    while(!q.empty())
    {
        int u=q.front(); q.pop();

        for(int i=Adj[u];~i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(dist[v]>dist[u]+edge[i].cost)
            {
                dist[v]=dist[u]+edge[i].cost;
                if(!inq[v])
                {
                    inq[v]=true;
                    q.push(v);
                }
            }
        }
        inq[u]=false;
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int cas=1;
    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++) scanf("%d",x+i);
        for(int i=1;i<=n;i++) scanf("%d",y+i);
        for(int i=1;i<=n;i++) scanf("%d",c+i);
        for(int i=1;i<=m;i++) scanf("%d",w+i);

        init();
        for(int i=1;i<=n;i++)
        {
            if(w[x[i]]==0) continue;
            ///对每个1/2战场连边
            Add_Edge(y[i],x[i],c[i]);
        }
        spfa();
        LL ans=0;
        for(int i=1;i<=m;i++)
        {
            if(w[i]==2)
            {
                ans+=dist[i];
                if(ans>=INF) 
                {
                    ans=-1; break;
                }
            }
        }
        printf("Case #%d: %lld\n",cas++,ans);
    }
    
    return 0;
}
```


