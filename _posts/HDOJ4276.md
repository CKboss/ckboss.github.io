title: HDOJ 4276 The Ghost Blows Light 树上分组背包
date: 2015-09-09 22:02:59
tags:
- acm
- acm_dp
categories:
- acm_dp
---


先判断从1号点能否顺利到n号点,并记录路径,和所需的时间.

然后从1号点开始跑树上的分组背包,需要注意的是:
1. 原路径上的点的权值提前加出来.
2. 路径上的两个点间的边长重置为0.

**dp方程**:
设v点为u的孩子,c为u到v的边长,$dp[u][vl]$表示在u点花了vl的时间,则v到u的转移为:
$$dp[u][vl]=max(dp[u][vl],dp[u][vl-j]+dp[v][j-c])$$

u可能有很多个孩子,依次按上面转移跑很多遍01背包即可.

***

### The Ghost Blows Light

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2788    Accepted Submission(s): 862


#### Problem Description

My name is Hu Bayi, robing an ancient tomb in Tibet. The tomb consists of N rooms (numbered from 1 to N) which are connected by some roads (pass each road should cost some time). There is exactly one route between any two rooms, and each room contains some treasures. Now I am located at the 1st room and the exit is located at the Nth room. 
Suddenly, alert occurred! The tomb will topple down in T minutes, and I should reach exit room in T minutes. Human beings die in pursuit of wealth, and birds die in pursuit of food! Although it is life-threatening time, I also want to get treasure out as much as possible. Now I wonder the maximum number of treasures I can take out in T minutes.
 

#### Input
There are multiple test cases.
The first line contains two integer N and T. (1 <= n <= 100, 0 <= T <= 500)
Each of the next N - 1 lines contains three integers a, b, and t indicating there is a road between a and b which costs t minutes. (1<=a<=n, 1<=b<=n, a!=b, 0 <= t <= 100)
The last line contains N integers, which Ai indicating the number of treasure in the ith room. (0 <= Ai <= 100)
 

#### Output
For each test case, output an integer indicating the maximum number of treasures I can take out in T minutes; if I cannot get out of the tomb, please output "Human beings die in pursuit of wealth, and birds die in pursuit of food!".
 
```
Sample Input
5 10
1 2 2 
2 3 2
2 5 3
3 4 3
1 2 3 4 5
 

Sample Output
11
```

Source
2012 ACM/ICPC Asia Regional Changchun Online
 

```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月09日 星期三 13时46分59秒
File Name     :HDOJ4276.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=200;
const int inf=0x3f3f3f3f;

int n,T;

struct Edge
{
	int to,next,cost;
}edge[maxn*2];

int Adj[maxn],Size;

void init()
{
	memset(Adj,-1,sizeof(Adj)); Size=0;
}

void Add_Edge(int u,int v,int c)
{
	edge[Size].to=v;
	edge[Size].next=Adj[u];
	edge[Size].cost=c;
	Adj[u]=Size++;
}

int dist[maxn],pre[maxn];
int valu[maxn];

void dfs(int u,int fa)
{
	pre[u]=fa;
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		int c=edge[i].cost;
		if(v==fa) continue;
		dist[v]=dist[u]+c;
		dfs(v,u);
	}
}

bool onroad[maxn];
int ans;

int findRoad()
{
	memset(onroad,false,sizeof(onroad));
	int u=n,ret=0;
	while(u!=pre[u]) { ret+=valu[u]; valu[u]=0; onroad[u]=true; u=pre[u]; }
	onroad[1]=true;
	ret+=valu[1]; valu[1]=0;
	return ret;
}

int dp[maxn][5*maxn];

//// fenzhu beibao
void DP(int u,int fa)
{
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		int c=edge[i].cost;
		if(v==fa) continue;
		DP(v,u);
		if(onroad[u]&&onroad[v]) c=0;
		for(int vl=T;vl>=0;vl--) /// 容量
		{
			for(int j=vl;j>=0;j--) /// 花费时间
			{
				dp[u][vl]=max(dp[u][vl],dp[u][vl-j]+dp[v][j-c]);
			}
		}
	}
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d%d",&n,&T)!=EOF)
	{
		init();
		for(int i=0;i<n-1;i++)
		{
			int u,v,c;
			scanf("%d%d%d",&u,&v,&c);
			Add_Edge(u,v,c); Add_Edge(v,u,c);
		}
		for(int i=1;i<=n;i++) 
		{
			scanf("%d",valu+i); pre[i]=i;
			///init dp
		}
		memset(dist,63,sizeof(dist)); dist[1]=0;
		dfs(1,1);

		if(dist[n]>T)
		{
			puts("Human beings die in pursuit of wealth, and birds die in pursuit of food!");
			continue;
		}
		//// find road

		ans=findRoad();
		T-=dist[n]; T/=2;

		memset(dp,0,sizeof(dp));
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=T;j++) 
			{
				if(onroad[i]==false) dp[i][j]=valu[i];
			}
		}

		DP(1,1);
		printf("%d\n",dp[1][T]+ans);
	}
    
    return 0;
}

```


