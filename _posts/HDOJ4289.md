title: HDOJ 4289 Control 拆点最小割
date: 2015-09-16 23:24:59
tags:
- 最大流
categories:
- acm_图论
---

最小割,因为权值在点上所以考虑拆点.
对于边 u->v , 连边 u'--->v 和 v'--->u
最后跑最大流即可

### Control

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2398    Accepted Submission(s): 1003


Problem Description
　　You, the head of Department of Security, recently received a top-secret information that a group of terrorists is planning to transport some WMD 1 from one city (the source) to another one (the destination). You know their date, source and destination, and they are using the highway network.
　　The highway network consists of bidirectional highways, connecting two distinct city. A vehicle can only enter/exit the highway network at cities only.
　　You may locate some SA (special agents) in some selected cities, so that when the terrorists enter a city under observation (that is, SA is in this city), they would be caught immediately.
　　It is possible to locate SA in all cities, but since controlling a city with SA may cost your department a certain amount of money, which might vary from city to city, and your budget might not be able to bear the full cost of controlling all cities, you must identify a set of cities, that:
　　* all traffic of the terrorists must pass at least one city of the set.
　　* sum of cost of controlling all cities in the set is minimal.
　　You may assume that it is always possible to get from source of the terrorists to their destination.

1 Weapon of Mass Destruction
 

##### Input
　　There are several test cases.
　　The first line of a single test case contains two integer N and M ( 2 <= N <= 200; 1 <= M <= 20000), the number of cities and the number of highways. Cities are numbered from 1 to N.
　　The second line contains two integer S,D ( 1 <= S,D <= N), the number of the source and the number of the destination.
　　The following N lines contains costs. Of these lines the ith one contains exactly one integer, the cost of locating SA in the ith city to put it under observation. You may assume that the cost is positive and not exceeding 107.
　　The followingM lines tells you about highway network. Each of these lines contains two integers A and B, indicating a bidirectional highway between A and B.
　　Please process until EOF (End Of File).
 

##### Output
　　For each test case you should output exactly one line, containing one integer, the sum of cost of your selected set.
　　See samples for detailed information.

<!-- more -->

```
Sample Input
5 6
5 3
5
2
3
4
12
1 5
5 4
2 3
2 4
4 3
2 1


Sample Output
3
```

Source
2012 ACM/ICPC Asia Regional Chengdu Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月16日 星期三 21时37分50秒
File Name     :HDOJ4289.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=520;
const int maxm=100400;
const int INF=0x3f3f3f3f;
const int MX=100000000;

struct Edge
{
	int to,next,cap,flow;
}edge[maxm];

int Size,Adj[maxn];
int gap[maxn],dep[maxn],pre[maxn],cur[maxn];

void init()
{
	Size=0; memset(Adj,-1,sizeof(Adj));
}

void addedge(int u,int v,int w,int rw=0)
{
	edge[Size].to=v; edge[Size].cap=w; edge[Size].next=Adj[u];
	edge[Size].flow=0; Adj[u]=Size++;

	edge[Size].to=u; edge[Size].cap=rw; edge[Size].next=Adj[v];
	edge[Size].flow=0; Adj[v]=Size++;
}

int sap(int start,int end,int N)
{
	memset(gap,0,sizeof(gap));
	memset(dep,0,sizeof(dep));
	memcpy(cur,Adj,sizeof(Adj));

	int u=start;
	pre[u]=-1; gap[0]=N;
	int ans=0;

	while(dep[start]<N)
	{
		if(u==end)
		{
			int Min=INF;
			for(int i=pre[u];~i;i=pre[edge[i^1].to])
			{
				if(Min>edge[i].cap-edge[i].flow)
					Min=edge[i].cap-edge[i].flow;
			}
			for(int i=pre[u];~i;i=pre[edge[i^1].to])
			{
				edge[i].flow+=Min;
				edge[i^1].flow-=Min;
			}
			u=start;
			ans+=Min;
			continue;
		}

		bool flag=false;
		int v;
		for(int i=cur[u];~i;i=edge[i].next)
		{
			v=edge[i].to;
			if(edge[i].cap-edge[i].flow&&dep[v]+1==dep[u])
			{
				flag=true;
				cur[u]=pre[v]=i;
				break;
			}
		}
		if(flag)
		{
			u=v; continue;
		}
		int Min=N;
		for(int i=Adj[u];~i;i=edge[i].next)
		{
			if(edge[i].cap-edge[i].flow&&dep[edge[i].to]<Min)
			{
				Min=dep[edge[i].to];
				cur[u]=i;
			}
		}
		gap[dep[u]]--;
		if(!gap[dep[u]]) return ans;
		dep[u]=Min+1;
		gap[dep[u]]++;
		if(u!=start) u=edge[pre[u]^1].to;
	}
	return ans;
}

int n,m,S,D;
int w[maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d%d",&n,&m)!=EOF)
	{
		scanf("%d%d",&S,&D);

		init();
		for(int i=1;i<=n;i++) 
		{
			scanf("%d",w+i);
			addedge(i,i+n,w[i]);
		}
		for(int i=0;i<m;i++)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			int uu=u+n;
			int vv=v+n;
			addedge(uu,v,MX);
			addedge(vv,u,MX);
		}

		addedge(0,S,MX);
		addedge(D+n,2*n+1,MX);

		int maxflow=sap(0,2*n+1,2*n+2);
		printf("%d\n",maxflow);
	}
    
    return 0;
}

```
