title: HDOJ 4163 Stock Prices 排序
date: 2015-11-05 21:22:56
tags:
- 排序
categories:
- acm_水
---

# [Stock Prices](http://acm.hdu.edu.cn/showproblem.php?pid=4163)

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 1026    Accepted Submission(s): 420


##### Problem Description
Buy low, sell high. That is what one should do to make profit in the stock market (we will ignore short selling here). Of course, no one can tell the price of a stock in the future, so it is difficult to know exactly when to buy and sell and how much profit one can make by repeatedly buying and selling a stock.

But if you do have the history of price of a stock for the last n days, it is certainly possible to determine the maximum profit that could have been made. Instead, we are interested in finding the k1 lowest prices and k2 highest prices in the history.
 

##### Input
The input consists of a number of cases. The first line of each case starts with positive integers n, k1, and k2 on a line (n <= 1,000,000, k1 + k2 <= n, k1, k2 <= 100). The next line contains integers giving the prices of a stock in the last n days: the i-th integer (1 <= i <= n) gives the stock price on day i. The stock prices are non-negative. The input is terminated by n = k1 = k2 = 0, and that case should not be processed.
 

##### Output
For each case, produce three lines of output. The first line contains the case number (starting from 1) on one line. The second line specifies the days on which the k1 lowest stock prices occur. The days are sorted in ascending order. The third line specifies the days on which the k2 highest stock prices occur, and the days sorted in descending order. The entries in each list should be separated by a single space. If there are multiple correct lists for the lowest prices, choose the lexicographically smallest list. If there are multiple correct lists for the highest prices, choose the lexicographically largest list.

```
Sample Input
10 3 2
1 2 3 4 5 6 7 8 9 10
10 3 2
10 9 8 7 6 5 4 3 2 1
0 0 0


Sample Output
Case 1
1 2 3
10 9
Case 2
8 9 10
2 1
```

##### Source
The 2011 Rocky Mountain Regional Contest

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月05日 星期四 20时04分02秒
File Name     :HDOJ4263.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

struct STK
{
    int val,id;
}Stk[1001000];

int n,k1,k2;

bool cmp(STK a,STK b)
{
    if(a.val!=b.val) return a.val<b.val;
    return a.id<b.id;
}

bool cmp1(STK a,STK b)
{
    return a.id<b.id;
}

bool cmp2(STK a,STK b)
{
    return a.id>b.id;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int cas=1;
    while(scanf("%d%d%d",&n,&k1,&k2)!=EOF)
    {
        if(n==0&&k1==0&&k2==0) break;
        for(int i=0,x;i<n;i++)
        {
            scanf("%d",&x);
            Stk[i].val=x; Stk[i].id=i+1;
        }
        printf("Case %d\n",cas++);

        sort(Stk,Stk+n,cmp);
        sort(Stk,Stk+k1,cmp1);

        for(int i=0;i<k1;i++)
        {
            printf("%d%c",Stk[i].id,(i==k1-1)?10:32);
        }

        sort(Stk+n-k2,Stk+n,cmp2);
        for(int i=k2-1;i>=0;i--)
        {
            printf("%d%c",Stk[n-1-i].id,(i==0)?10:32);
        }
    }
   
    return 0;
}
```


