title: HDOJ 5476 Explore Track of Point 计算几何
date: 2015-09-27 22:58:49

tags:
- 几何
- 观察法

categories:
- acm_计算几何

---


* 所形成的两个角为180度.

* **观察下图...**
可以发现p点可能在中线上,或者在三角形两腰相切形成的圆弧上....

然后随便写写就可以ac了...

![示意图](http://ww1.sinaimg.cn/mw1024/50a04a61gw1ewhemzcxoij20d30hoabj.jpg)


### Explore Track of Point

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 280    Accepted Submission(s): 110


##### Problem Description
In Geometry, the problem of track is very interesting. Because in some cases, the track of point may be beautiful curve. For example, in polar Coordinate system, ρ=cos3θ is like rose, ρ=1−sinθ is a Cardioid, and so on. Today, there is a simple problem about it which you need to solve.

Give you a triangle ΔABC and AB = AC. M is the midpoint of BC. Point P is in ΔABC and makes min{∠MPB+∠APC,∠MPC+∠APB} maximum. The track of P is Γ. Would you mind calculating the length of Γ?

Given the coordinate of A, B, C, please output the length of Γ.
 

##### Input
There are T (1≤T≤104) test cases. For each case, one line includes six integers the coordinate of A, B, C in order. It is guaranteed that AB = AC and three points are not collinear. All coordinates do not exceed 104 by absolute value.
 

##### Output
For each case, first please output "Case #k: ", k is the number of test case. See sample output for more detail. Then, please output the length of Γ with exactly 4 digits after the decimal point.
 
```cpp
Sample Input
1
0 1 -1 0 1 0
 

Sample Output
Case #1: 3.2214
```

Source
2015 ACM/ICPC Asia Regional Shanghai Online

<!-- more -->


```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月27日 星期日 22时30分08秒
File Name     :HDOJ5476.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const double eps=1e-6;
const double pi=acos(-1.0);

int dcmp(double x){if(fabs(x)<eps) return 0; return (x<0)?-1:1;}

struct Point
{
    double x,y;
    Point(double _x=0,double _y=0):x(_x),y(_y){};
	void toString()
	{
		printf("point: (%lf,%lf)\n",x,y);
	}
};

Point operator+(Point A,Point B) {return Point(A.x+B.x,A.y+B.y);}
Point operator-(Point A,Point B) {return Point(A.x-B.x,A.y-B.y);}
Point operator*(Point A,double p) {return Point(A.x*p,A.y*p);}
Point operator/(Point A,double p) {return Point(A.x/p,A.y/p);}

bool operator<(const Point&a,const Point&b){return a.x<b.x||(a.x==b.x&&a.y<b.y);}

bool operator==(const Point&a,const Point&b){return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;}

double Dot(Point A,Point B) {return A.x*B.x+A.y*B.y;}
double Length(Point A) {return sqrt(Dot(A,A));}
double Angle(Point A,Point B) {return acos(Dot(A,B)/Length(A)/Length(B));}
double Angle(Point v) {return atan2(v.y,v.x);}
double Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}

/**Cross
    P*Q > 0 P在Q的顺时针方向
    P*Q < 0 P在Q的逆时针方向
    P*Q = 0 PQ共线
*/

Point Horunit(Point x) {return x/Length(x);}///单位向量
Point Verunit(Point x) {return Point(-x.y,x.x)/Length(x);}///单位法向量

Point Rotate(Point A,double rad)///逆时针旋转(围绕原点)
{
    return Point(A.x*cos(rad)-A.y*sin(rad),A.x*sin(rad)+A.y*cos(rad));
}

double Area2(const Point A,const Point B,const Point C)
{
    return Cross(B-A,C-A);
}

/// 过两点p1, p2的直线一般方程ax+by+c=0  (x2-x1)(y-y1) = (y2-y1)(x-x1)
void getLineGeneralEquation(const Point& p1, const Point& p2, double& a, double&b, double &c)
{
    a = p2.y-p1.y;
    b = p1.x-p2.x;
    c = -a*p1.x - b*p1.y;
}

///P+t*v Q+w*t的焦点
Point GetLineIntersection(Point P,Point v,Point Q,Point w)
{
    Point u=P-Q;
    double t=Cross(w,u)/Cross(v,w);
    return P+v*t;
}

///点到直线距离
double DistanceToLine(Point P,Point A,Point B)
{
    Point v1=B-A,v2=P-A;
    return fabs(Cross(v1,v2))/Length(v1);
}

///有向直线
struct Line
{
    Point p;
    Point v;
    double ang;
    Line(Point _p,Point _v):p(_p),v(_v){ang=atan2(v.y,v.x);}
    Point point(double a) {return p+(v*a);}
    bool operator<(const Line& L)const
    {
        return ang<L.ang;
    }
};

double RtoDegree(double x) {return x/pi*180.;}

Point A,B,C,M;

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T,cas=1;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%lf%lf%lf%lf%lf%lf",&A.x,&A.y,&B.x,&B.y,&C.x,&C.y);
		M.x=(B.x+C.x)/2.; M.y=(B.y+C.y)/2.;

		double ans=Length(M-A);
		Point v1=A-B,v2=A-C;
		v1=Rotate(v1,-pi/2);
		v2=Rotate(v2,pi/2);

		Point cross = GetLineIntersection(B,v1,C,v2);

		double r=Length(cross-B);
		double ag=Angle(B-cross,C-cross);

		ans+=r*ag;

		printf("Case #%d: %.4lf\n",cas++,ans);
	}
    
    return 0;
}
```
