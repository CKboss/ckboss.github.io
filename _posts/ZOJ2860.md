title: ZOJ 2860 Breaking Strings 四边形优化DP
date: 2015-10-29 14:12:38
tags:
- dp
- ZOJ

categories:
- acm_dp

---

区间dp,四边形优化...

# [Breaking Strings](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1860)
Time Limit: 2 Seconds      Memory Limit: 65536 KB

A certain string-processing language allows the programmer to break a string into two pieces. Since this involves copying the old string, it costs n units of time to break a string of n characters into two pieces. Suppose a programmer wants to break a string into many pieces. The order in which the breaks are made can affect the total amount of time used. For example, suppose we wish to break a 20 character string after characters 3, 8, and 10 (numbering the characters in ascending order from the left-hand end, starting from 1). If the breaks are made in left-to-right order, then the first break cost 20 units of time, the second break costs 17 units of time, and the third breaks costs 12 units of time, a total of 49 units of time (see the sample below). If the breaks are made in right-to-left order, then the first break costs 20 units of time, the second break costs 10 units of time, and the third break costs 8 units of time, a total of 38 units of time.

The cost of making the breaks in left-to-right order:

thisisastringofchars     (original)
thi sisastringofchars    (cost:20 units)
thi sisas tringofchars   (cost:17 units)
thi sisas tr ingofchars  (cost:12 units)
                         Total: 49 units.
The cost of making the breaks in right-to-left order:

thisisastringofchars     (original)
thisisastr ingofchars    (cost:20 units)
thisisas tr ingofchars   (cost:10 units)
thi sisas tr ingofchars  (cost: 8 units)
                         Total: 38 units.
##### Input:

There are several test cases! In each test case, the first line contains 2 integers N (2<=N<=10000000) and M (1<=M<=1000, M<N). N is the original length of the string, and M is the number of the breaks. The following lines contain M integers Mi (1<=Mi<N) in ascending order that represent the breaking positions from the string's left-hand end.

##### Output:

For each test case, output in one line the least cost to make all the breakings.

```
Sample Input:

20 3
3 8 10
Sample Output:

37
```

Author: Wei, Qizheng
Source: ZOJ Monthly, June 2007

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月29日 星期四 11时31分21秒
File Name     :ZOJ2860.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;
const int maxn=1111;

int l,n;
int a[maxn];
LL dp[maxn][maxn];
int m[maxn][maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    while(scanf("%d%d",&l,&n)!=EOF)
    {
        for(int i=1;i<=n;i++) scanf("%d",a+i);
        a[n+1]=l; n++; sort(a,a+n);

        memset(dp,63,sizeof(dp));
        memset(m,-1,sizeof(m));

        for(int i=1;i<=n;i++)
        {
            dp[i][i]=0; m[i][i]=i;
        }
        for(int i=1;i<n;i++)
        {
            int j=i+1;
            dp[i][j]=a[j]-a[i-1];
            m[i][j]=i;
        }

        for(int len=3;len<=n;len++)
        {
            for(int i=1;i+len-1<=n;i++)
            {
                int j=i+len-1;

                int from=m[i][j-1];
                int to=m[i+1][j];

                for(int k=from;k<=to;k++)
                {
                    LL tmp=dp[i][k]+dp[k+1][j]+a[j]-a[i-1];
                    if(tmp<dp[i][j])
                    {
                        dp[i][j]=tmp;
                        m[i][j]=k;
                    }
                }
            }
        }

        printf("%lld\n",dp[1][n]);
    }
    
    return 0;
}
```