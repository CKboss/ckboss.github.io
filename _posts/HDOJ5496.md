title: HDOJ 5496 Beauty of Sequence 组合数学
date: 2015-10-05 09:52:11
tags:
-  递推
-  组合数学

categories:
- acm_数学

---

**考虑每个数字对最终答案的贡献. 对于每个数, 我们只算它出现在连续相同元素的第一个时的贡献, 这样会使计算简便很多. 假设这个数是$a[i]$a, 那么i后面的随便选有$2^{n-i}$种. 考虑$a[i]$前面的数, 要么一个不选, 要么选择的最后一个数和$a[i]$不同, 然后就可以算出来了.**

### [Beauty of Sequence](http://acm.hdu.edu.cn/showproblem.php?pid=5496)

Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 378    Accepted Submission(s): 165


##### Problem Description
Sequence is beautiful and the beauty of an integer sequence is defined as follows: removes all but the first element from every consecutive group of equivalent elements of the sequence (i.e. unique function in C++ STL) and the summation of rest integers is the beauty of the sequence.

Now you are given a sequence A of n integers {a1,a2,...,an}. You need find the summation of the beauty of all the sub-sequence of A. As the answer may be very large, print it modulo 109+7.

Note: In mathematics, a sub-sequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example {1,3,2} is a sub-sequence of {1,4,3,5,2,1}.


##### Input
There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:

The first line contains an integer n (1≤n≤105), indicating the size of the sequence. The following line contains n integers a1,a2,...,an, denoting the sequence (1≤ai≤109).

The sum of values n for all the test cases does not exceed 2000000.


##### Output
For each test case, print the answer modulo 109+7 in a single line.

```cpp
Sample Input
3
5
1 2 3 4 5
4
1 2 1 3
5
3 3 2 1 2


Sample Output
240
54
144
```

##### Source
BestCoder Round #58 (div.2)

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月04日 星期日 10时01分29秒
File Name     :HDOJ5496.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

const int maxn=101000;
const LL mod=1000000007LL;

int n,hn;
LL Hash[maxn],a[maxn];
LL same[maxn];

int QuickPow(LL a,int n)
{
	LL e=1LL;
	while(n)
	{
		if(n%2) e=(e*a)%mod;
		a=(a*a)%mod; n/=2;
	}
	return e%mod;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n); hn=0;
		for(int i=1;i<=n;i++) 
		{
			scanf("%lld",a+i);
			same[i]=0; Hash[hn++]=a[i];
		}

		sort(Hash,Hash+hn);
		hn=unique(Hash,Hash+hn)-Hash;

		LL ans=0; LL sum=0;
		for(int i=1;i<=n;i++)
		{
			int pos=lower_bound(Hash,Hash+hn,a[i])-Hash+1;

			LL xs_right=QuickPow(2,n-i);
			LL xs_left=(sum-same[pos]+mod+1)%mod;

			ans=(ans+((a[i]*xs_left)%mod*xs_right)%mod)%mod;

			same[pos]=(same[pos]+QuickPow(2,i-1))%mod;
			sum=(sum+QuickPow(2,i-1))%mod;
		}

		printf("%lld\n",ans);
	}
    
    return 0;
}
```

