title: HDOJ 5452 Minimum Cut 树链剖分
date: 2015-09-19 22:03:22
tags:
- 树链剖分
categories:
- acm_数据结构
---

在树上每加一条边,就会形成一个环.
如果要切掉在这个环上的树边,那么就要多切掉这条边才可以.

所以,原题既为求树上边权的最小值,用树链剖分解决.

### Minimum Cut

Time Limit: 3000/2000 MS (Java/Others)    Memory Limit: 65535/102400 K (Java/Others)
Total Submission(s): 269    Accepted Submission(s): 104


##### Problem Description
Given a simple unweighted graph G (an undirected graph containing no loops nor multiple edges) with n nodes and m edges. Let T be a spanning tree of G.
We say that a cut in G respects T if it cuts just one edges of T.

Since love needs good faith and hypocrisy return for only grief, you should find the minimum cut of graph G respecting the given spanning tree T.
 

##### Input
The input contains several test cases.
The first line of the input is a single integer t (1≤t≤5) which is the number of test cases.
Then t test cases follow.

Each test case contains several lines.
The first line contains two integers n (2≤n≤20000) and m (n−1≤m≤200000).
The following n−1 lines describe the spanning tree T and each of them contains two integers u and v corresponding to an edge.
Next m−n+1 lines describe the undirected graph G and each of them contains two integers u and v corresponding to an edge which is not in the spanning tree T.
 

##### Output
For each test case, you should output the minimum cut of graph G respecting the given spanning tree T.
 
```
Sample Input
1
4 5
1 2
2 3
3 4
1 3
1 4
 

Sample Output
Case #1: 2
```

Source
2015 ACM/ICPC Asia Regional Shenyang Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :Saturday, September 19, 2015 PM01:56:52 CST
File Name     :C.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=202200;
const int INF=0x3f3f3f3f;

struct Edge
{
    int to,next;
}edge[maxn*2];

int Adj[maxn],Size;

void init_edge()
{
    memset(Adj,-1,sizeof(Adj)); Size=0;
}

void add_edge(int u,int v)
{
    edge[Size].to=v; edge[Size].next=Adj[u]; Adj[u]=Size++;
}

int fa[maxn],deep[maxn],num[maxn],son[maxn];
int top[maxn],p[maxn],rp[maxn],pos;

void init()
{
    init_edge();
    memset(son,-1,sizeof(son));
    pos=1;
}

void dfs1(int u,int pre,int d)
{
    num[u]=1; fa[u]=pre; deep[u]=d;
    for(int i=Adj[u];~i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==pre) continue;
        dfs1(v,u,d+1);
        num[u]+=num[v];
        if(son[u]==-1||num[son[u]]<num[v])
            son[u]=v;
    }
}

void getPos(int u,int to)
{
    top[u]=to;
    p[u]=pos++;
    rp[p[u]]=u;
    if(son[u]!=-1) getPos(son[u],to);
    for(int i=Adj[u];~i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v!=fa[u]&&v!=son[u]) getPos(v,v);
    }
}

int n,m;

int Arr[maxn];

void DOIT(int u,int v)
{
    int f1=top[u],f2=top[v];
    while(f1!=f2)
    {
        if(deep[f1]<deep[f2])
        {
            swap(f1,f2); swap(u,v);
        }
        //// update
        Arr[p[f1]-1]++; Arr[p[u]]--;

        u=fa[f1]; f1=top[u];
    }
    if(u==v) return ;
    if(deep[u]>deep[v]) swap(u,v);
    Arr[p[son[u]]-1]++; Arr[p[v]]--;
}


int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T,cas=1;
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d%d",&n,&m);
        init();
        for(int i=0;i<n-1;i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            add_edge(u,v); add_edge(v,u);
        }
        dfs1(1,1,0);
        getPos(1,1);
        memset(Arr,0,sizeof(int)*(n+10));

        int x,y;
        for(int i=n-1;i<m;i++)
        {
            scanf("%d%d",&x,&y);
            DOIT(x,y);
        }
        int ans=Arr[1];
        for(int i=1;i<=n-1;i++)
        {
            Arr[i]+=Arr[i-1];
            ans=min(ans,Arr[i]);
        }
        printf("Case #%d: %d\n",cas++,ans+1);
    }
    
    return 0;
}
```
