title: HDOJ 5469 Antonidas 暴力+bitset
date: 2015-10-02 00:40:30
tags:
- bitset
- 暴力

categories:
- acm_暴力

---

暴力DFS,对每个节点用一个bitset记录这个点可以匹配的前缀的位置和后缀的位置....

写法比较有讲究,容易TLE和MLE,(~~代码在G++中ac,C++ MLE~~)....

### [Antonidas](http://acm.hdu.edu.cn/showproblem.php?pid=5469)

Time Limit: 8000/4000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 529    Accepted Submission(s): 142


##### Problem Description
Given a tree with N vertices and N−1 edges. Each vertex has a single letter Ci. Given a string S, you are to choose two vertices A and B, and make sure the letters catenated on the shortest path from A to B is exactly S. Now, would you mind telling me whether the path exists?
 

##### Input
The first line is an integer T, the number of test cases.
For each case, the first line is an integer N. Following N−1 lines contains two integers a and b, meaning there is an edge connect vertex a and vertex b.
Next line contains a string C, the length of C is exactly N. String C represents the letter on each vertex.
Next line contains a string S.
1≤T≤200, 1≤N≤104, 1≤a,b≤N, a≠b, |C|=N, 1≤|S|≤104. String C and S both only contain lower case letters.
 

##### Output
First, please output "Case #k: ", k is the number of test case. See sample output for more detail.
If the path exists, please output “Find”. Otherwise, please output “Impossible”.

```cpp
Sample Input
2

7
1 2
2 3
2 4
1 5
5 6
6 7
abcdefg
dbaefg

5
1 2
2 3
2 4
4 5
abcxy
yxbac
 

Sample Output
Case #1: Find
Case #2: Impossible
```

Source
2015 ACM/ICPC Asia Regional Shanghai Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月01日 星期四 22时40分55秒
File Name     :HDOJ5469_2.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <bitset>

using namespace std;

const int maxn=10020;

typedef bitset<10005> BB;

struct Edge
{
	int to,next;
}edge[20000];

int Adj[maxn],Size;
BB mp1[maxn],mp2[maxn];
deque<int> q1[maxn],q2[maxn];
int n,m;
char str[maxn],c[maxn];
bool Flag;

void init()
{
	Size=0;
	for(int i=0;i<=n+5;i++)
	{
		Adj[i]=-1;
		mp1[i].reset(); mp2[i].reset();
		q1[i].clear(); q2[i].clear();
	}
}

void Add_Edge(int u,int v)
{
	edge[Size].to=v;
	edge[Size].next=Adj[u];
	Adj[u]=Size++;
}

void dfs(int u,int fa)
{
	if(Flag==true) return ;

	for(int i=Adj[u];~i&&Flag==false;i=edge[i].next)
	{
		int v=edge[i].to;

		if(v==fa) continue;
		dfs(v,u);

		int sz=q1[v].size();
		for(int j=0;j<sz;j++)
		{
			/// 从v号点的前缀转移过来
			int x=q1[v].front(); 
			q1[v].pop_front(); q1[v].push_back(x); /// 移动到队末

			if(str[u]==c[x+1])
			{
				if(mp1[u][x+1]==0) 
				{
					mp1[u][x+1]=1;
					q1[u].push_back(x+1);
				}
				else mp2[u][x+1]=1;

				if(x+1==m) { Flag=true; break; }
			}
		}
	}

	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;

		/// 去掉v前缀
		int sz=q1[v].size();
		for(int j=0;j<sz;j++)
		{
			int x=q1[v].front(); 
			q1[v].pop_front(); q1[v].push_back(x); /// 移动到队末

			if((c[x+1]==str[u])&&(mp2[u][x+1]==0))
			{
				mp1[u][x+1]=0;
			}
		}

		/// 用v的后缀来匹配u的前缀
		sz=q2[v].size();
		for(int j=0;j<sz;j++)
		{
			int x=q2[v].front();
			q2[v].pop_front(); /// 移动到队末
			if(mp1[u][x-1]==1)
			{
				Flag=true; break;
			}
			/// 更新一下u可以表示的后缀
			if(c[x-1]==str[u])
			{
				q2[u].push_back(x-1);
				if(x-1==1)
				{
					Flag=true; break;
				}
			}
		}

		if(Flag==true) break;

		sz=q1[v].size();
		for(int j=0;j<sz;j++)
		{
			int x=q1[v].front(); 
			q1[v].pop_front();/// 移动到队末

			if((c[x+1]==str[u])&&(mp2[u][x+1]==0))
			{
				mp1[u][x+1]=1;
			}
		}
	}

	if(str[u]==c[1]) q1[u].push_back(1);
	if(str[u]==c[m]) q2[u].push_back(m);
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T,cas=1;
	scanf("%d",&T_T);

	while(T_T--)
	{
		scanf("%d",&n);
		init();
		for(int i=0,u,v;i<n-1;i++)
		{
			scanf("%d%d",&u,&v);
			Add_Edge(u,v); Add_Edge(v,u);
		}

		scanf("%s",str+1);
		scanf("%s",c+1);
		m=strlen(c+1);

		Flag=false;
		if(m==1)
		{
			/// special judge
			for(int i=1;i<=n&&Flag==false;i++)
			{
				if(str[i]==c[1]) Flag=true;
			}
		}
		else if(m<=n)
		{
			dfs(1,1);
		}

		if(Flag==true) printf("Case #%d: Find\n",cas++);
		else printf("Case #%d: Impossible\n",cas++);
	}
	
    return 0;
}
```
