title: HDOJ 4609 3-idiots FFT+组合数

date: 2015-11-08 20:15:51

tags:
- FFT

categories:
- acm_数论

---

FFT+组合数,结果又遭遇了莫名奇妙的WA,重写又提交15+后终于过了.

##### 题意:
给n个数,随机的选择3个数.问能构成三角形的概率是多少.

##### 解:
既求有多少种方法可以构成三角形.
可以枚举两个边的和,再来看第三边,由于n比较大,所以用FFT来计算出所有可能的和(感觉类似母函数).

比如对于输入 1 3 3 4,对应的多项式为:

$f = x^4+2 x^3+x^4$
则:
$f * f = x^8+4 x^7+4 x^6+2 x^5+4 x^4+x^2$

这个可以用FFT算,表示在f中可以重复的选两个数可以组成1个2,4个4,2个5,4个6,4个7,1个8


* 因为不能有一个数被减去两次,所以需要将指数等于a[i]*2的项减小１．

* 因为取的两个数没有顺序的区别，所以所有的系数都要除以２．

* 用sum数组来累加前缀和.

对于某一个数设为x(假设数组已经排序,x在数组的第i位上,比x小的边既在x前面的边,比x大的既在x后面的边),下面来计算选择x做为所在三角形的最长的边,有多少种不同的三角形.

1. 有$D=sum[len]-sum[x]$种两边的和是可以大于$x$的,但是这些情况中包含了很多不合法的情况
2. 考虑到$x$为三角形中的最长边,在$D$中有$A=n-1$种情况,所选的两条边中包含了$x$
3. 同理,在$D$中有$B=(n-i-1)*i$种情况,所选的两条边是一个比$x$大的边(位置靠后)和一个比$x$小的(位置靠前)边
4. 在D中有$C=(n-i-1)*(n-i-2)/2$种情况,所选的两条边都比$x$大(位置靠后)
5. x所能贡献的三角形个数为: $D-A-B-C$

可以在$O(n)$的时间内统计出答案

# [3-idiots](http://acm.hdu.edu.cn/showproblem.php?pid=4609)

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3233    Accepted Submission(s): 1114


##### Problem Description
King OMeGa catched three men who had been streaking in the street. Looking as idiots though, the three men insisted that it was a kind of performance art, and begged the king to free them. Out of hatred to the real idiots, the king wanted to check if they were lying. The three men were sent to the king's forest, and each of them was asked to pick a branch one after another. If the three branches they bring back can form a triangle, their math ability would save them. Otherwise, they would be sent into jail.
However, the three men were exactly idiots, and what they would do is only to pick the branches randomly. Certainly, they couldn't pick the same branch - but the one with the same length as another is available. Given the lengths of all branches in the forest, determine the probability that they would be saved.


##### Input
An integer T(T≤100) will exist in the first line of input, indicating the number of test cases.
Each test case begins with the number of branches N(3≤N≤105).
The following line contains N integers a_i (1≤a_i≤105), which denotes the length of each branch, respectively.


##### Output
Output the probability that their branches can form a triangle, in accuracy of 7 decimal places.

```
Sample Input
2
4
1 3 3 4
4
2 3 3 4
 

Sample Output
0.5000000
1.0000000
```

##### Source
2013 Multi-University Training Contest 1

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月08日 星期日 16时41分24秒
File Name     :HDOJ4609.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

/*********************FFT************************/

const double PI=acos(-1.0);

struct Complex 
{
    double x,y;
    Complex(double _x=0,double _y=0):x(_x),y(_y){}
    Complex operator + (const Complex &b) const
    {
        return Complex(x+b.x,y+b.y);
    }
    Complex operator - (const Complex &b) const
    {
        return Complex(x-b.x,y-b.y);
    }
    Complex operator * (const Complex &b) const
    {
        return Complex(x*b.x-y*b.y,x*b.y+y*b.x);
    }
    void toString()
    {
        printf("%.2lf + %.2lf i\n",x,y);
    }
};

void change(Complex y[],int len)
{
    int i,j,k;
    for(i=1,j=len/2;i<len-1;i++)
    {
        if(i<j) swap(y[i],y[j]);
        k=len/2;
        while(j>=k)
        {
            j-=k; k/=2;
        }
        if(j<k) j+=k;
    }
}

void fft(Complex y[],int len,int on)
{
    change(y,len);
    for(int h=2;h<=len;h<<=1)
    {
        Complex wn(cos(-on*2*PI/h),sin(-on*2*PI/h));
        for(int j=0;j<len;j+=h)
        {
            Complex w(1,0);
            for(int k=j;k<j+h/2;k++)
            {
                Complex u=y[k];
                Complex t=w*y[k+h/2];
                y[k]=u+t;
                y[k+h/2]=u-t;
                w=w*wn;
            }
        }
    }
    if(on==-1)
    {
        for(int i=0;i<len;i++) y[i].x/=len;
    }
}

/************************************************/

typedef long long int LL;

const int maxn=840000;

Complex cx[maxn];
LL xi[maxn];
LL cnt[maxn];
LL sum[maxn];
int len,n,a[maxn];

void init()
{
    memset(cnt,0,sizeof(cnt));
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        init();
        scanf("%d",&n);
        for(int i=0;i<n;i++)
        {
            scanf("%d",a+i);
            cnt[a[i]]++;
        }
        sort(a,a+n);
        len=1; int len1=a[n-1]+1;
        while(len<len1*2) len=len*2;

        for(int i=0;i<len1;i++)
            cx[i]=Complex(cnt[i],0);
        for(int i=len1;i<len;i++)
            cx[i]=Complex(0,0);

        fft(cx,len,1); 
        for(int i=0;i<len;i++) cx[i]=cx[i]*cx[i];
        fft(cx,len,-1);

        for(int i=0;i<len;i++)
            xi[i]=(LL)(cx[i].x+0.5);

        len=2*a[n-1];

        for(int i=0;i<n;i++)
            xi[a[i]+a[i]]--;

        sum[0]=0;
        for(int i=1;i<=len;i++)
        {
            xi[i]/=2;
            sum[i]=sum[i-1]+xi[i];
        }

        LL ans=0;
        for(int i=0;i<n;i++)
        {
            ans+=sum[len]-sum[a[i]];

            ans-=(LL)(n-1-i)*i;
            ans-=(LL)(n-1-i)*(n-2-i)/2;
            ans-=n-1;
        }

        LL tot=(LL)n*(n-1)*(n-2)/6;
        printf("%.7lf\n",(double)ans/tot);
    }
    
    return 0;
}
```
