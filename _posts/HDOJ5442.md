title: HDOJ 5442 Favorite Donut SAM+KMP
date: 2015-09-13 22:32:13
tags: 
- KMP
- SAM

categories:
- acm_字符串

---

求长度为n的字典序最大的子串,这个可以把原串*2后在SAM上用DFS求.
匹配的位置可以用KMP

很裸的SAM和KMP,但比赛的时候把一个记录长度的变量写成了char型,无论如何都WA但小数据又不会出错....挣扎了几个小数后无奈wa....

---
### Favorite Donut

Time Limit: 1500/1000 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)
Total Submission(s): 470    Accepted Submission(s): 124


<!-- more -->
##### Problem Description
Lulu has a sweet tooth. Her favorite food is ring donut. Everyday she buys a ring donut from the same bakery. A ring donut is consists of n parts. Every part has its own sugariness that can be expressed by a letter from a to z (from low to high), and a ring donut can be expressed by a string whose i-th character represents the sugariness of the i−th part in clockwise order. Note that z is the sweetest, and two parts are equally sweet if they have the same sugariness.

Once Lulu eats a part of the donut, she must continue to eat its uneaten adjacent part until all parts are eaten. Therefore, she has to eat either clockwise or counter-clockwise after her first bite, and there are 2n ways to eat the ring donut of n parts. For example, Lulu has 6 ways to eat a ring donut abc: abc,bca,cab,acb,bac,cba. Lulu likes eating the sweetest part first, so she actually prefer the way of the greatest lexicographic order. If there are two or more lexicographic maxima, then she will prefer the way whose starting part has the minimum index in clockwise order. If two ways start at the same part, then she will prefer eating the donut in clockwise order. Please compute the way to eat the donut she likes most.
 

##### Input
First line contain one integer T,T≤20, which means the number of test case.

For each test case, the first line contains one integer n,n≤20000, which represents how many parts the ring donut has. The next line contains a string consisted of n lowercase alphabets representing the ring donut.
 

##### Output
You should print one line for each test case, consisted of two integers, which represents the starting point (from 1 to n) and the direction (0 for clockwise and 1 for counterclockwise).
 
```
Sample Input
2
4
abab
4
aaab
 

Sample Output
2 0
4 0
```

Source
2015 ACM/ICPC Asia Regional Changchun Online
 




```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月13日 星期日 12时13分28秒
File Name     :1006.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int CHAR=30,maxn=101000;

struct SAM_Node
{
    SAM_Node *fa,*next[CHAR];
    int len,id,pos;
    SAM_Node(){}
    SAM_Node(int _len)
    {
        fa=0; len=_len;
        memset(next,0,sizeof(next));
    }
};

SAM_Node SAM_node[maxn*2],*SAM_root,*SAM_last;
int SAM_size;

SAM_Node *newSAM_Node(int len)
{
    SAM_node[SAM_size]=SAM_Node(len);
    SAM_node[SAM_size].id=SAM_size;
    return &SAM_node[SAM_size++];
}

SAM_Node *newSAM_Node(SAM_Node *p)
{
    SAM_node[SAM_size]=*p;
    SAM_node[SAM_size].id=SAM_size;
    return &SAM_node[SAM_size++];
}

void SAM_init()
{
    SAM_size=1;
    SAM_root=SAM_last=newSAM_Node(0);
    SAM_node[0].pos=0;
}

void SAM_add(int x,int len)
{
    SAM_Node *p=SAM_last,*np=newSAM_Node(p->len+1);
    np->pos=len;SAM_last=np;
    for(;p&&!p->next[x];p=p->fa)
        p->next[x]=np;
    if(!p)
    {
        np->fa=SAM_root;
        return ;
    }
    SAM_Node *q=p->next[x];
    if(q->len==p->len+1)
    {
        np->fa=q;
        return ;
    }
    SAM_Node *nq=newSAM_Node(q);
    nq->len=p->len+1;
    q->fa=nq; np->fa=nq;
    for(;p&&p->next[x]==q;p=p->fa)
        p->next[x]=nq;
}

void SAM_build(char *s)
{
    SAM_init();
    int len=strlen(s);
    for(int i=0;i<len;i++) SAM_add(s[i]-'a',i+1);
}

void PT(int u)
{
    for(int i=0;i<26;i++)
    {
        if(SAM_node[u].next[i])
        {
            cout<<u<<" -- "<<(char)(i+'a')<<" --> "<<SAM_node[u].next[i]->id<<endl;
        }
    }
}

bool flag;
int len;
char biger[maxn];
int bn;
char biger1[maxn],biger2[maxn];

void dfs(int pos,int u)
{
    if(flag==true) return ;

    if(pos==len) 
    { 
        flag=true; bn=pos;
        return ; 
    }
    for(int i=26;i>=0&&flag==false;i--)
    {
        if(SAM_node[u].next[i])
        {
            if(flag==false) 
            {
                biger[pos]=(char)('a'+i);
                dfs(pos+1,SAM_node[u].next[i]->id);
            }
        }
    }
}


/**********************************/

int f[maxn];

void getfail(char* p,int* f)
{
    int m=strlen(p);
    f[0]=f[1]=0;
    for(int i=1;i<m;i++)
    {
        int j=f[i];
        while(j&&p[j]!=p[i]) j=f[j];
        f[i+1]=(p[i]==p[j])?j+1:0;
    }
}

int kmp(int kind,char* t,char* p,int* f)
{
    int n=strlen(t),m=strlen(p);
    getfail(p,f);
    int j=0;
    int ret=-1;
    for(int i=0;i<n;i++)
    {
        while(j&&p[j]!=t[i]) j=f[j];
        if(p[j]==t[i]) j++;
        if(j==m)
        {
            if(kind==0) return i-m+1;
            else if(kind==1)
            {
                if(ret==-1) ret=i-m+1;
                ret=max(ret,i-m+1); 
            }
            j=f[j];
        }
    }
    return ret;
}

char str[maxn];
char str1[maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d",&len);
        memset(biger,0,sizeof(biger));
        memset(biger1,0,sizeof(biger1));
        scanf("%s",str);
        //len=strlen(str);
        int pos=len;
        for(int i=0;i<len-1;i++)
            str[pos++]=str[i];
        str[pos]=0;
        SAM_init();
        SAM_build(str);

        flag=false;
        dfs(0,SAM_root->id);
        bn=len;
        biger[bn]=0;
        for(int i=0;i<bn;i++) biger1[i]=biger[i]; biger1[bn]=0;

        for(int i=0;i<len;i++)
            str1[i]=str[len-1-i];
        pos=len;
        for(int i=0;i<len-1;i++)
            str1[pos++]=str1[i];
        str1[pos]=0;

        SAM_init();
        SAM_build(str1);
        flag=false;
        dfs(0,SAM_root->id);
        bn=len;
        biger[bn]=0;

        int diff=strcmp(biger1,biger);
        int id;
        if(diff>0)
        {
            /// zheng
            id=kmp(0,str,biger1,f);
            printf("%d 0\n",id+1); 
        }
        else if(diff<0)
        {
            /// fan
            id=kmp(1,str1,biger,f);
            printf("%d 1\n",(len-1-id)+1);
        }
        else if(diff==0)
        {
            int id1=kmp(0,str,biger1,f);
            int id2=kmp(1,str1,biger,f);
            if(id1+1<=(len-1-id2)+1) printf("%d 0\n",id1+1); 
            else printf("%d 1\n",(len-1-id2)+1);
        }
    }
    
    return 0;
}
```