title: ZOJ 2561 Order-Preserving Codes 四边形优化DP
date: 2015-10-27 23:08:27
tags:
- dp优化

categories:
- acm_dp

---

求安字典序递增的huffman编码,区间DP但是得用四边形优化...

## [Order-Preserving Codes](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1561)

Time Limit: 5 Seconds      Memory Limit: 65536 KB      Special Judge
Binary code is a mapping of characters of some alphabet to the set of finite length bit sequences. For example, standard ASCII code is a fixed length code, where each character is encoded using 8 bits.

Variable length codes are often used to compress texts taking into account the frequencies of occurence of different characters. Characters that occur more often get shorter codes, while characters occuring less often -- longer ones.

To ensure unique decoding of variable length codes so called prefix codes are usually used. In a prefix code no code sequence is a proper prefix of another sequence. Prefix code can be easily decoded scanning the encoded sequence from left to right, since no code is the prefix of another, one always knows where the code for the current character ends and the new character starts.

Among prefix codes, the optimal code is known, so called Huffman code. It provides the shortest possible length of the text among all prefix codes that separatly encode each character with an integer number of bits.

However, as many other codes, Huffman code does not preserve character order. That is, Huffman codes for lexicographically ordered characters are not necessarily lexicographicaly ordered.

In this problem you are asked to develop a prefix code that would be optimal for the given text among all order-preserving prefix codes. Code is called order-preserving if for any two characters the code sequence for the character that goes earlier in the alphabet is lexicographically smaller.

Since text itself is not essential for finding the code, only the number of occurences of each character is important, only this data is given.

##### Input:

The input consists of several test cases

For each test case, the first line contains n -- the number of characters in the alphabet (2 <= n <= 2000). The next line contains n integer numbers -- the number of occurences of the characters in the text for which the code must be developed (numbers are positive and do not exceed 109). Characters are described in the alphabetical order.

##### Output:

For each test case, Output n bit sequences, one on a line -- the optimal order-preserving prefix code for the described text.

```
Sample Input:
5
1 8 2 3 1
Sample Output:
00
01
10
110
111
```

Author: Andrew Stankevich
Source: Andrew Stankevich's Contest #4

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月27日 星期二 15时40分41秒
File Name     :ZOJ2561.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

const int maxn=2222;
const LL INF=0x3f3f3f3f3f3f3f3f;


int n;
int a[maxn];
LL s[maxn];
LL dp[maxn][maxn];
int pre[maxn][maxn];

void OPT(int p,int L,int R)
{
    if(L==R) 
    {
        putchar(10);
        return ;
    }
    int m = pre[L][R];
    if(p<=m)
    {
        putchar('0');
        OPT(p,L,m);
    }
    else if(p>m)
    {
        putchar('1');
        OPT(p,m+1,R);
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    while(scanf("%d",&n)!=EOF)
    {
        memset(dp,63,sizeof(dp));
        memset(pre,-1,sizeof(pre));
        for(int i=1;i<=n;i++) 
        {
            scanf("%d",a+i);
            s[i]=s[i-1]+a[i];
            dp[i][i]=0;
        }
        for(int j=1;j+1<=n;j++)
        {
            dp[j][j+1]=s[j+1]-s[j-1];
            pre[j][j+1]=j;
        }
        for(int len=3;len<=n;len++)
        {
            for(int j=1;j+len-1<=n;j++)
            {
                int L=j,R=j+len-1;
                int from=pre[L][R-1];
                int to=pre[L+1][R];
                for(int k=from;k<=to;k++)
                {
                    //dp[L][R]=min(dp[L][k]+dp[k+1][R]+s[R]-s[L-1],dp[L][R]);
                    if(dp[L][k]+dp[k+1][R]+s[R]-s[L-1]<dp[L][R])
                    {
                        dp[L][R]=dp[L][k]+dp[k+1][R]+s[R]-s[L-1];
                        pre[L][R]=k;
                    }
                }
            }
        }
        for(int i=1;i<=n;i++) OPT(i,1,n);
    }
    
    return 0;
}
```