title: HDOJ 5536 Chip Factory
date: 2015-11-02 20:20:31
tags:
- trie

categories:
- acm_数据结构

---

经典问题:　从n个数中选俩个求异或值最大
建立01字典树就可以了

# [Chip Factory](http://acm.hdu.edu.cn/showproblem.php?pid=5536)

Time Limit: 18000/9000 MS (Java/Others)    Memory Limit: 262144/262144 K (Java/Others)
Total Submission(s): 207    Accepted Submission(s): 119


##### Problem Description
John is a manager of a CPU chip factory, the factory produces lots of chips everyday. To manage large amounts of products, every processor has a serial number. More specifically, the factory produces n chips today, the i-th chip produced this day has a serial number si.

At the end of the day, he packages all the chips produced this day, and send it to wholesalers. More specially, he writes a checksum number on the package, this checksum is defined as below:
$$maxi,j,k(si+sj)⊕sk$$

which i,j,k are three different integers between 1 and n. And ⊕ is symbol of bitwise XOR.

Can you help John calculate the checksum number of today?


##### Input
The first line of input contains an integer T indicating the total number of test cases.

The first line of each test case is an integer n, indicating the number of chips produced today. The next line has n integers s1,s2,..,sn, separated with single space, indicating serial number of each chip.

1≤T≤1000
3≤n≤1000
0≤si≤109
There are at most 10 testcases with n>100
 

##### Output
For each test case, please output an integer indicating the checksum number in a line.

```
Sample Input
2
3
1 2 3
3
100 200 300
 

Sample Output
6
400
```

Source
2015ACM/ICPC亚洲区长春站-重现赛（感谢东北师大）

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月02日 星期一 19时22分16秒
File Name     :HDOJ5536.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=1200;

int n;
int a[maxn];
int num[maxn*32];
int ch[maxn*31][2];
int bit[33];
int nextnode;

void init()
{
    nextnode=1;
    memset(ch,0,sizeof(ch));
    memset(num,0,sizeof(num));
}

void fj(int x)
{
    memset(bit,0,sizeof(bit));
    for(int i=0;i<31;i++)
    {
        bit[i]=x&1; x/=2;
    }
}

void insert(int x,int add)
{
    fj(x);
    int now=0;
    for(int i=30;i>=0;i--)
    {
        int d=bit[i];
        if(ch[now][d]==0) ch[now][d]=nextnode++;
        now=ch[now][d];
        num[now]+=add;
    }
}

int query(int x)
{
    fj(x);
    int ret=0;
    int now=0;
    for(int i=30;i>=0;i--)
    {
        int d=bit[i];
        int rd=1-d;
        if(num[ch[now][rd]]) 
        {
            now=ch[now][rd];
            ret=ret<<1|1;
        }
        else if(num[ch[now][d]]) 
        {
            now=ch[now][d];
            ret=ret<<1;
        }
        else
        {
            puts("oh no!!!");
        }
    }
    return ret;
}

void debug()
{
    for(int i=0;i<nextnode;i++)
    {
        cout<<i<<" num: "<<num[i]<<" left: "<<ch[i][0]<<" right: "<<ch[i][1]<<endl;
    }
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        init();
        scanf("%d",&n);
        for(int i=0;i<n;i++) 
        {
            scanf("%d",a+i);
            insert(a[i],1);
        }
        int ans=0;
        for(int i=0;i<n;i++)
        {
            insert(a[i],-1);
            for(int j=i+1;j<n;j++)
            {
                insert(a[j],-1);
                int c=a[i]+a[j];
                int q=query(c);
                ans=max(ans,q);
                insert(a[j],1);
            }
            insert(a[i],1);
        }
        printf("%d\n",ans);
    }
    
    return 0;
}
```
