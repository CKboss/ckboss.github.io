title: HDOJ 4291 A Short problem 循环节+矩阵快速幂
date: 2015-09-17 22:26:45
tags:
- 矩阵快速幂
categories:
- acm_数论
---

[很好的讲解](http://www.51nod.com/question/index.html?questionId=591)

> 求g(g(g(n))) mod 1000000007，设g(g(n)) = k，那么问题变为了g(k) mod 1000000007，
我们需要求出mod 1000000007的循环节长度L1，则g(k) mod 1000000007 = g(k mod L1) mod 1000000007，所以问题转为了求L1以及k mod L1 = g(g(n)) % L1。忽然发现同最初要求的问题是那么的相似！
再经过一次转换之后，就变为求L1,L2以及g(n) % L2，实际上g(n)的问题不用太担心，有矩阵乘法作保障，可以有log(n)的方法，详见@林建华 构造的那个矩阵。所以问题的核心是如何求L1，L2。

### A Short problem

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2324    Accepted Submission(s): 812


##### Problem Description
　　According to a research, VIM users tend to have shorter fingers, compared with Emacs users.
　　Hence they prefer problems short, too. Here is a short one:
　　Given n (1 <= n <= 1018), You should solve for 
g(g(g(n))) mod 109 + 7

　　where
g(n) = 3g(n - 1) + g(n - 2)

g(1) = 1

g(0) = 0

 

##### Input
　　There are several test cases. For each test case there is an integer n in a single line.
　　Please process until EOF (End Of File).
 

##### Output
　　For each test case, please print a single line with a integer, the corresponding answer to this case.
 
```
Sample Input
0
1
2
 

Sample Output
0
1
42837
```

Source
2012 ACM/ICPC Asia Regional Chengdu Online
 
<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月17日 星期四 21时36分16秒
File Name     :HDOJ4291.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

const LL mod[3]={183120LL,222222224LL,1000000007LL};

struct Matrix
{
	LL m[2][2];
	Matrix() { memset(m,0,sizeof(m)); }
	void E() { m[0][0]=m[1][1]=1; }
};

Matrix mulit(Matrix a,Matrix b,LL mod)
{
	Matrix ret;
	for(int i=0;i<2;i++)
	{
		for(int j=0;j<2;j++)
		{
			for(int k=0;k<2;k++)
			{
				ret.m[i][j]=(ret.m[i][j]+a.m[i][k]*b.m[k][j]%mod)%mod;
			}
		}
	}
	return ret;
}

Matrix QuickPow(Matrix a,LL n,LL mod)
{
	Matrix e;
	e.E();
	while(n)
	{
		if(n%2LL) e=mulit(e,a,mod);
		a=mulit(a,a,mod);
		n/=2LL;
	}
	return e;
}

LL getX(LL x,LL mod)
{
	if(x==0) return 0LL;
	if(x==1) return 1LL;
	x-=1;

	Matrix m;
	m.m[0][0]=3; m.m[0][1]=1; m.m[1][0]=1; m.m[1][1]=0;
	m=QuickPow(m,x,mod);
	LL ret=m.m[0][0];

	return ret%mod;
}

void solve(LL x)
{
	LL x1=getX(x,mod[0]);
	LL x2=getX(x1,mod[1]);
	LL x3=getX(x2,mod[2]);

	printf("%lld\n",x3%mod[2]);
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	LL x;
	while(scanf("%lld",&x)!=EOF) { solve(x); }
    
    return 0;
}
```
