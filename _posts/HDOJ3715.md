title: HDOJ 3715 Go Deeper 2-SAT+二分
date: 2015-10-30 15:51:46
tags:
- 2-SAT
- 二分
- HDOJ

categories:
- acm_图论

---

二分答案,2-SAT判断是否可行.

#### **2-SAT建图总结:**

##### ++2-SAT建图的要点是只建必要边.++
###### 比如:
A(a,a'),B(b,b')两对点,如果A和B不能同时选,那么考虑a选择了a则必须选择b',这是一个**必要边**.考虑a',没有选择A则B可以选也可以不选,那么就**不是必要边**,不要连接a'到其他点的边.

对于题,考虑c分别为0,1,2的各种情况:

A(a选,a'不选),B(b选,b'不选)

* c==0时: A+B!=0 , 选择了a'则必须得选b,选择了b'必须选择a这两条是必要边.

$$a'\longrightarrow b$$
$$b'\longrightarrow a$$

* c==1时: A+B!=1 , 选择了a必须选择b,选择b必须选择a,同理a'和b'都得互选

$$a'\longrightarrow b'$$
$$b'\longrightarrow a'$$
$$a\longrightarrow b$$
$$b\longrightarrow a$$

* c==2是: A+B!=2 , 选择了a必须选择b',选择了b必须选择a'.

$$ a \longrightarrow b' $$
$$ b \longrightarrow a' $$

建图只建**必要边**,这题的建图可以自己推一下...
2-SAT的两个,特殊情况.
* 必须选择A连边: $a'\longrightarrow a$
* 必须不选择A连边: $a \longrightarrow a'$

连好边后,可以跑一遍tarjan.一个点的两个分量不能在同一个联通分量上.

# [Go Deeper](http://acm.hdu.edu.cn/showproblem.php?pid=3715)

Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 2599    Accepted Submission(s): 830


##### Problem Description
Here is a procedure's pseudocode:

go(int dep, int n, int m)
begin
output the value of dep.
if dep < m and x[a[dep]] + x[b[dep]] != c[dep] then go(dep + 1, n, m)
end

In this code n is an integer. a, b, c and x are 4 arrays of integers. The index of array always starts from 0. Array a and b consist of non-negative integers smaller than n. Array x consists of only 0 and 1. Array c consists of only 0, 1 and 2. The lengths of array a, b and c are m while the length of array x is n. Given the elements of array a, b, and c, when we call the procedure go(0, n, m) what is the maximal possible value the procedure may output?


##### Input
There are multiple test cases. The first line of input is an integer T (0 < T ≤ 100), indicating the number of test cases. Then T test cases follow. Each case starts with a line of 2 integers n and m (0 < n ≤ 200, 0 < m ≤ 10000). Then m lines of 3 integers follow. The i-th(1 ≤ i ≤ m) line of them are ai-1 ,bi-1 and ci-1 (0 ≤ ai-1, bi-1 < n, 0 ≤ ci-1 ≤ 2).


##### Output
For each test case, output the result in a single line.

```
Sample Input
3
2 1
0 1 0
2 1
0 0 0
2 2
0 1 0
1 1 2


Sample Output
1
1
2
```

Author
CAO, Peng


Source
2010 Asia Chengdu Regional Contest

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月30日 星期五 15时00分05秒
File Name     :HDOJ3715.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=11000;
const int maxm=1100;

int n,m;
int a[maxn],b[maxn],c[maxn];

/********* tarjan *****************/

struct Edge
{
    int to,next;
}edge[maxm*maxm];

int Adj[maxm],Size;

void init() { memset(Adj,-1,sizeof(Adj)); Size=0; }

void Add_Edge(int u,int v)
{
    edge[Size].to=v;
    edge[Size].next=Adj[u];
    Adj[u]=Size++;
}

int Low[maxm],DFN[maxm],Stack[maxm],Belong[maxm];
int Index,top,scc,N;
bool Instack[maxm];

void tarjan(int u)
{
    int v;
    Low[u]=DFN[u]=++Index;
    Stack[top++]=u;
    Instack[u]=true;
    for(int i=Adj[u];~i;i=edge[i].next)
    {
        v=edge[i].to;
        if(!DFN[v])
        {
            tarjan(v);
            Low[u]=min(Low[u],Low[v]);
        }
        else if(Instack[v])
        {
            Low[u]=min(Low[u],DFN[v]);
        }
    }
    if(Low[u]==DFN[u])
    {
        scc++;
        do
        {
            v=Stack[--top];
            Instack[v]=false;
            Belong[v]=scc;
        }while(v!=u);
    }
}

void SCC()
{
    memset(DFN,0,sizeof(DFN));
    memset(Instack,false,sizeof(Instack));

    Index=scc=0;

    for(int i=0;i<N;i++)
    {
        if(!DFN[i]) tarjan(i);
    }
}

void Build_Graph(int mid)
{
    init();
    for(int i=0;i<mid;i++)
    {
        if(c[i]==0)
        {
            Add_Edge(a[i],b[i]+n);
            Add_Edge(b[i],a[i]+n);
        }
        else if(c[i]==1)
        {
            Add_Edge(a[i],b[i]);
            Add_Edge(b[i],a[i]);
            Add_Edge(a[i]+n,b[i]+n);
            Add_Edge(b[i]+n,a[i]+n);
        }
        else if(c[i]==2)
        {
            Add_Edge(a[i]+n,b[i]);
            Add_Edge(b[i]+n,a[i]);
        }
    }
}

bool CC(int limit)
{
    Build_Graph(limit);
    SCC();
    bool flag=true;
    for(int i=0;i<n&&flag;i++)
    {
        if(Belong[i]==Belong[i+n]) flag=false;
    }
    return flag;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d%d",&n,&m);
        for(int i=0;i<m;i++)
        {
            scanf("%d%d%d",a+i,b+i,c+i);
        }
        int low=0,mid,high=m;
        int ans=0;
        N=2*n;
        while(low<=high)
        {
            mid=(low+high)/2;

            if(CC(mid)==true)
            {
                ans=mid;
                low=mid+1;
            }
            else
            {
                high=mid-1;
            }
        }
        printf("%d\n",ans);
    }
    
    return 0;
}
```


