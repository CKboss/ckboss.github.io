title: HDOJ 2463 USTC campus network BFS

date: 2015-11-05 10:52:53

tags:
- bfs

categories:
- acm_图论

---

BFS搜索...

# [USTC campus network](http://acm.hdu.edu.cn/showproblem.php?pid=2463)

Time Limit: 8000/4000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 467    Accepted Submission(s): 157


##### Problem Description
USTC campus network is a huge network. There is a bi-directional link between every pair of computers in the network. One of the computers is the BBS server, which is so popular that thousands of people log on it every day. Recently some links of the network are damaged by the rainstorm. The network administrator is going to check which computers are still connected with the BBS server directly or indirectly.

You are to help the administrator to report the number of computers still connecting with the BBS server (not including itself).
 

##### Input
The input consists of multiple test cases. Each test case starts with a line containing two integers N and M (1 ≤ N ≤ 10,000, 0 ≤ M ≤ 1,000,000), which are the number of computers and the number of damaged links in USTC campus network, respectively. The computers are numbered from 1 to N and computer 1 is the BBS server.
Each of the following M lines contains two integers A and B(1 ≤ A ≤ N, 1 ≤ B ≤ N, A ≠ B), which means the link between computer A and B is damaged. A link will appear at most once.

The last test case is followed by a line containing two zeros.
 

##### Output
For each test case, print a line containing the test case number( beginning with 1) followed by the number of computers still connecting with the BBS server.

```
Sample Input
3 2
1 2
1 3
4 3
1 2
3 2
4 2
0 0
 

Sample Output
Case 1: 0
Case 2: 2
```

##### Source
2008 Asia Hefei Regional Contest Online by USTC

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月05日 星期四 10时37分51秒
File Name     :HDOJ2463.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=10100;

map<int,int> S[maxn];
int n,m;
int ans;
set<int> List;
set<int>::iterator it;
bool conn[maxn];
queue<int> q;

void BFS()
{
    q.push(1);
    for(int i=2;i<=n;i++) List.insert(i);

    while(!q.empty())
    {
        int u=q.front(); q.pop();

        for(it=List.begin();it!=List.end();)
        {
            int v=*it;
            if(conn[v]==false&&S[v][u]!=1)
            {
                it=List.erase(it);
                ans++;
                conn[v]=true;
                q.push(v);
            }
            else it++;
        }
    }
}

void init()
{
    while(!q.empty()) q.pop();
    for(int i=0;i<=n+10;i++)
    {
        S[i].clear();
        conn[i]=false;
    }
    ans=0;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int cas=1;
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        if(n==0&&m==0) break;
        init();
        for(int i=0,x,y;i<m;i++)
        {
            scanf("%d%d",&x,&y);
            S[x][y]=1; S[y][x]=1;
        }
        BFS();
        printf("Case %d: %d\n",cas++,ans);
    }
    
    return 0;
}
```



