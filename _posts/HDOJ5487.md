title: HDOJ 5487 Difference of Languages BFS+想法
date: 2015-09-29 00:30:38
tags:
- BFS
- 想法题
categories:
- acm_想法

---

因为节点数比较少,记录到两个dfa的节点的转移,用BFS找答案...

[详见ICPC-CAMP上关于这题的讨论](http://talk.icpc-camp.org/d/92-2015-d-difference-of-languages)

---

### Difference of Languages

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 277    Accepted Submission(s): 65


##### Problem Description
A regular language can be represented as a deterministic finite automaton (DFA). A DFA contains a finite set of states Q and a finite set of input symbols called the alphabet Σ. Initially, the DFA is positioned at the start state q0∈Q. Given the transition function δ(q,a) and an input symbol a, the DFA transit to state δ(q,a) if its current state is q.
Let w=a1a2…an be a string over the alphabet Σ. According to the above definition, the DFA transits through the following sequence of states.
q0,q1=δ(q0,a1),q2=δ(q1,a2),…,qn=δ(qn−1,an)

The DFA also contains a set of accept states F⊆Q. If the last state qn is an accept state, we say that the DFA accepts the string w. The set of accepted strings is referred as the language that the DFA represents.
You are given two DFAs, and the languages that they represent may be different. You want to find the difference between the two languages. Specifically, you are trying to find a string that is accepted by one DFA but not accepted by the other DFA. As there could be multiple such strings, you only want the shortest one. If there are still multiple such strings, you would like the smallest one in lexicographical order.

 

##### Input
The first line of input contains a number T indicating the number of test cases (T≤200).
Each test case contains the description of two DFAs.
For the first DFA, the first line contains three integers N, M, and K, indicating the number of states, the number of rules describing the transition function, and the number of accept states (1≤K≤N≤1000,0≤M≤26N). The states are numbered from 0 to N–1. The start state is always 0.
The second line contains K integers representing the accept states. All these numbers are distinct.
Each of the next M lines consists of two states p and q, and an input symbol a, which means that the DFA transits from p to q when it receives the symbol a. You may assume that the alphabet in consideration consists of the 26 lowercase letters (a-z). It is guaranteed that, given p and a, the next state q is unique.
The description of the second DFA follows the same format as the above. 
 

##### Output
For each test case, output a single line consisting of “Case #X: Y”. X is the test case number starting from 1. Y is the shortest string that is accepted by one DFA but not accepted by the other DFA. If no such string exists, output the digit “0” instead. Note that an empty string is also considered a string.
 
```
Sample Input
2
3 3 1
2
0 1 a
1 2 b
2 0 c
4 4 1
3
0 1 a
1 2 b
2 3 c
3 0 a
3 3 1
2
0 1 a
1 2 b
2 0 c
3 4 1
2
0 1 a
1 2 b
1 2 c
2 0 c
 

Sample Output
Case #1: ab
Case #2: ac
```

Source
2015 ACM/ICPC Asia Regional Hefei Online

<!-- more -->


```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月28日 星期一 23时28分56秒
File Name     :HDOJ5487.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=1110;

struct DFA
{
    int n,m,k;
    int End[maxn];
    int G[maxn][26];

    void init()
    {
        memset(End,0,sizeof(End));
        memset(G,0,sizeof(G));
    }

    void read()
    {
        init();
        scanf("%d%d%d",&n,&m,&k);
        for(int i=0,x;i<k;i++)
        {
            scanf("%d",&x);
            x++;
            End[x]=1;
        }
        char str[3];
        for(int i=0,u,v;i<m;i++)
        {
            scanf("%d%d%s",&u,&v,str);
            u++; v++;
            int c=str[0]-'a';
            G[u][c]=v;
        }
    }

}dfa1,dfa2;

int d[maxn][maxn]; /// 第几次走到
int p[maxn][maxn]; /// 字符和从哪里来

const int H=2000;

void gao()
{
    memset(d,-1,sizeof(d));
    memset(p,-1,sizeof(p));

    d[1][1]=0;

    queue<int> q;
    q.push(1); q.push(1);

    while(!q.empty())
    {
        int x=q.front(); q.pop();
        int y=q.front(); q.pop();

        if(dfa1.End[x]^dfa2.End[y])
        {
            /// find a ans;
            string ans;
            int V=p[x][y];

            while(true)
            {
                if(V==-1) break;

                int Y=V%H; V/=H;
                int X=V%H; V/=H;

                ans+='a'+V;

                V=p[X][Y];
            }

            for(int i=ans.length()-1;i>=0;i--)
                putchar(ans[i]);
            putchar(10);

            return ;
        }

        for(int i=0;i<26;i++)
        {
            int X=dfa1.G[x][i];
            int Y=dfa2.G[y][i];

            if(d[X][Y]==-1)
            {
                d[X][Y]=d[x][y]+1;
                p[X][Y]=(i*H+x)*H+y;

                q.push(X); q.push(Y);
            }
        }
    }
    puts("0");
}

void solve()
{
    dfa1.read(); dfa2.read(); gao();
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T,cas=1;
    scanf("%d",&T_T);
    while(T_T--) 
    {
        printf("Case #%d: ",cas++);
        solve();
    }

    return 0;
}

```


