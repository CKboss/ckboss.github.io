title: HDOJ 5473 There was a kingdom 凸包+DP
date: 2015-10-03 15:40:34
tags:
- 凸包
- dp
- 随机化

categories:
- acm_计算几何

---

先求出凸包,再用随机化选点,最后DP

### There was a kingdom

Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 394    Accepted Submission(s): 78


##### Problem Description
Once upon a time, there was a kingdom ruled by a wise king. 
After years of his reign, by means of successful economic actions, the kingdom, with n cities, became an economic power soon.
Without nation defense, the development of the state economy will be hurt, the king said.
After days of serious thoughts, the king finally decided to choose k cities to cover as more area as possible (the area covered by k cities equals to the area of the convex formed by these k points).
However, the king don't know how to choose the optimal way to do it. Please help him!
 

##### Input
The input consists of multiple test cases.
The first line of the input gives the number of test cases, T (1≤T≤200). T test cases follow.
Each test case starts with two integer n (1≤n≤100) and k (1≤k≤n).
Then following n lines contains two integers x and y, the coordinates of the cities.
−107≤x≤107, −107≤y≤107.
It is guaranteed that there are no more than 30 test cases in which n≥50.
 

##### Output
Please output "Case #k: res", k is the number of test case and res is maximum area multiply 2, to make sure res is always an integer.

```cpp
Sample Input
1
5 3
10 -2
-7 -10
-3 -8
-10 10
-10 5


Sample Output
Case #1: 364
```

##### Source
2015 ACM/ICPC Asia Regional Shanghai Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月03日 星期六 12时49分41秒
File Name     :HDOJ5473.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

struct Point
{
    LL x,y;
    Point(){}
    Point(int _x,int _y):x(_x),y(_y){}
    void toString()
    {
        printf("(%lld,%lld)\n",x,y);
    }
};

Point operator+(Point A,Point B) { return Point(A.x+B.x,A.y+B.y); }
Point operator-(Point A,Point B) { return Point(A.x-B.x,A.y-B.y); }

bool operator<(const Point& a,const Point& b) { return (a.x<b.x)||((a.x==b.x)&&(a.y<b.y)); }
bool operator==(const Point& a,const Point& b) { return (a.x==b.x)&&(a.y==b.y); }

LL Cross(Point A,Point B) { return A.x*B.y-A.y*B.x; }
LL Area2(const Point A,const Point B,const Point C) { return Cross(B-A,C-A); }

/// 有向多边形的面积

LL PolygonArea2(vector<Point>& p,int n)
{
    LL area=0;
    for(int i=1;i<n-1;i++) area+=Cross(p[i]-p[0],p[i+1]-p[0]);
    return area;
}

/// 凸包
vector<Point> CovexHull(vector<Point>& p) 
{
    sort(p.begin(),p.end());
    p.erase(unique(p.begin(),p.end()),p.end());
    int n=p.size(); int m=0;
    vector<Point> ch(n+1);
    for(int i=0;i<n;i++)
    {
        while(m>1&&Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0) m--;
        ch[m++]=p[i];
    }
    int k=m;
    for(int i=n-2;i>=0;i--)
    {
        while(m>k&&Cross(ch[m-1]-ch[m-2],p[i]-ch[m-2])<=0) m--;
        ch[m++]=p[i];
    }
    if(n>1) m--;
    ch.resize(m);
    return ch;
}

int N,K;
LL allarea;
vector<Point> poly,ch;

/// 前n个取k个可以得到的最大面积
LL dp[110][110];

LL DP(int s)
{
    memset(dp,0,sizeof(dp));
    dp[0][0]=allarea;

    for(int i=1;i<=N;i++)
    {
        int u=(i+s)%N;
        LL sum=0;

        for(int j=i-1;j>=0;j--)
        {
            int v=(j+s)%N;
            int w=(v+1)%N;

            LL tmp=abs(Area2(poly[u],poly[v],poly[w]));
            sum+=tmp;

            for(int k=K;k>0;k--)
            {
                dp[i][k]=max(dp[i][k],dp[j][k-1]-sum);
            }
        }
    }

    return dp[N][K];
}

bool vis[110];

LL Solve()
{
    if(K>=N) { return allarea; }
    if(K<3) return 0;

    /// 随机选取...个点
    memset(vis,false,sizeof(vis));
    int ttt=min((N/K)*10,N);
    LL ret=0;

    while(ttt--)
    {
        int s=rand()%N;
        if(vis[s]==true) { ttt++; continue; }
        vis[s]=true;
        DP(s);
        ret=max(ret,dp[N][K]);
    }

    return ret;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int cas=1,T_T;
    srand(32333);
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d%d",&N,&K);
        poly.clear();
        for(int i=0,x,y;i<N;i++)
        {
            scanf("%d%d",&x,&y);
            poly.push_back(Point(x,y));
        }
        ch=CovexHull(poly);
        N=ch.size(); poly=ch;
        allarea=abs(PolygonArea2(ch,N));
        LL ans=Solve();
        printf("Case #%d: %lld\n",cas++,ans);
    }
    
    return 0;
}
```

