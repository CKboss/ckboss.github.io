title: UVA 10600 - ACM Contest and Blackout 次小生成树Java版

date: 2015-11-06 22:57:02

tags:
- 次小生成树

categories:
- acm_图论

---

求一最小生成树和一个次小生成树....
**坑: 图有重边,略麻烦一些**

#### 次小生成树求法:
先求出最小生成树,然后dfs预处理出在MST上从u到v路径上的最大的边长.最后枚举不在MST上的边,找到最小的差值$edge[u,v]-MaxBetween[u,v]$,次小生成树就是最小生成树加上这个差值.


<embed width="100%" height="100%" name="plugin" src="http://7xjob4.com1.z0.glb.clouddn.com/88cf8b14ffc3b4adffd415e43e058681" type="application/pdf" internalinstanceid="14">

```java
import java.util.*;

public class Main {

    final int maxn=111;
    final int INF=0x3f3f3f3f;

    int[][] G = new int[maxn][maxn];
    int[][] Gid = new int[maxn][maxn];
    boolean[][] tree = new boolean[maxn][maxn];
    boolean[] E_used = new boolean[maxn*maxn];
    int[] pre = new int[maxn];
    int[][] MaxBetween = new int[maxn][maxn];

    void init() {
        for(int i=0;i<111;i++) {
            Arrays.fill(MaxBetween[i],0);
            Arrays.fill(G[i],INF);
            Arrays.fill(tree[i],false);
            G[i][i]=0; pre[i]=i;
        }
        Arrays.fill(E_used,false);
    }

    int n,m;

    int MST() {

        int[] dist = new int[maxn];
        boolean[] vis = new boolean[maxn];

        Arrays.fill(dist,INF);
        Arrays.fill(vis,false);

        dist[1]=0;

        int sum=0;

        for(int i=0;i<n;i++) {

            int mark=-1,mindist=INF;

            for(int j=1;j<=n;j++) {

                if(vis[j]==false&&dist[j]<mindist) {
                    mark=j; mindist=dist[j];
                }

            }

            if(mark==-1) return INF;

            sum+=mindist; vis[mark]=true;

            for(int j=1;j<=n;j++) {

                if(vis[j]==false&&G[mark][j]<dist[j]) {
                    dist[j]=G[mark][j];
                    pre[j]=mark;
                }

            }
        }

        for(int i=1;i<=n;i++) {
            tree[pre[i]][i]=tree[i][pre[i]]=true;
            E_used[Gid[pre[i]][i]]=true;
        }
        tree[1][1]=false;

        return sum;
    }

    void dfs(int goal,int u,int fa,int val) {

        MaxBetween[goal][u]=val;

        for(int v=1;v<=n;v++) {
            if(v==fa) continue;
            if(G[u][v]>=INF) continue;
            if(tree[u][v]==true) {
                 dfs(goal,v,u,Math.max(val,G[u][v]));
            }
        }
    }

    void PRE() {
        for(int i=1;i<=n;i++) {
            dfs(i,i,-1,0);
        }
    }

    class ED {
        int id,u,v,c;
        ED(int _id,int _u,int _v,int _c) {
            id=_id; u=_u; v=_v; c=_c;
        }

        @Override
        public String toString() {
            return "id: "+id+" "+u+" <---> "+v+" c: "+c;
        }
    }

    Vector<ED> ve = new Vector<ED>();

    Main() {

        Scanner in = new Scanner(System.in);

        int T_T=in.nextInt();
        while(T_T-->0) {

            init();
            ve = new Vector<ED>();

            n=in.nextInt(); m=in.nextInt();
            for(int i=0,x,y,c;i<m;i++) {
                x=in.nextInt();
                y=in.nextInt();
                c=in.nextInt();

                ED edge = new ED(i+1,x,y,c);
                ve.add(edge);

                if(G[x][y]>=c) {
                    G[x][y]=G[y][x]=c;
                    Gid[x][y]=Gid[y][x]=i+1;
                }
            }

            int ans1=MST();
            PRE();
            int deta=INF;
            /// enmu every edge not on the MST
            for(ED edge : ve) {

                if(E_used[edge.id]==true) continue;
                int u=edge.u,v=edge.v,c=edge.c;
                deta=Math.min(deta,c-MaxBetween[u][v]);
            }

            System.out.println(ans1+" "+(ans1+deta));
        }
    }

    public static void main(String[] args) {
        new Main();
    }
}
```