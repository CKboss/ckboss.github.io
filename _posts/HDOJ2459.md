title: HDOJ 2459 Maximum repetition substring SA

date: 2015-11-04 22:57:26

tags:
- 后缀数组

categories:
- acm_字符串


---

后缀数组神题....

#### [题解:](http://blog.csdn.net/libin56842/article/details/46317153)

> 容易想到的就是枚举长度为L，然后看长度为L的字符串最多连续出现几次。

> 长度为L的串重复出现，那么st[0],st[l],st[2*l]……st[k*l]中肯定有两个连续的出现在字符串中。不然肯定长度不超过2*L啊。那么我们就枚举连续的两个，然后从这两个字符前后匹配，看最多能匹配多远。
即以st[i*l],st[i*l+l]前后匹配，这里是通过查询suffix(i*l),suffix(i*l+l)的最长公共前缀通过rank值能找到i*l,与i*l+l的排名，我们要查询的是这段区间的height的最小值，通过RMQ预处理达到查询为0(1)的复杂度，设LCP长度为M, 则答案显然为M / L + 1, 但这只是以i*l和i*l+l为起点的情况, 不过有一点是可以确定的。如果目标子串包含了i*l和i*l+l。那么 i*l一定是和i*l+l匹配的。因为目标串中p一定和p+l匹配。这样才能满足子串长度为l。先在要解决的就是起点不在这两个位置上怎么办了。得到M/L+1我们可以试着把答案变大。如果M%L!=0我们可以把长度补齐到L的整数倍。即在前面增加(L-M%L)的字符.看能不能使答案变大。为什么这样做是可以的呢？因为我们要使啊、答案变大往后扩展肯定不行了。因为后面已经不匹配了。但是我们为什么扩展 (L-M%L)这么多就行了呢。比这个小肯定是不行的。因为还是没到L的整数倍。比这个多能行的话。去这个值一定能行。因为p是和p+L匹配的。既然取得比这个多。大不了往右平移几个还是能使 M%L得到匹配。那为什么只扩展一个长度L。不扩展多个呢。因为你是枚举每个i*l和i*l+l。你扩展2个或两个以上就是前面的 i*l和i*l+l的情况了。这一步完成后我们只能得到度数最大长度可能的取值。剩下的工作就是找字典序最小了。 通过sa数组进行枚举，取到的第一组，肯定是字典序最小的。

# [Maximum repetition substring](http://acm.hdu.edu.cn/showproblem.php?pid=2459)

Time Limit: 3000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 886    Accepted Submission(s): 237


##### Problem Description
The repetition number of a string is defined as the maximum number R such that the string can be partitioned into R same consecutive substrings. For example, the repetition number of "ababab" is 3 and "ababa" is 1.

Given a string containing lowercase letters, you are to find a substring of it with maximum repetition number.
 

##### Input
The input consists of multiple test cases. Each test case contains exactly one line, which
gives a non-empty string consisting of lowercase letters. The length of the string will not be greater than 100,000.

The last test case is followed by a line containing a '#'.
 

##### Output
For each test case, print a line containing the test case number( beginning with 1) followed by the substring of maximum repetition number. If there are multiple substrings of maximum repetition number, print the lexicographically smallest one.

```
Sample Input
ccabababc
daabbccaa
#
 

Sample Output
Case 1: ababab
Case 2: aa
```

##### Source
2008 Asia Hefei Regional Contest Online by USTC

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月04日 星期三 20时18分58秒
File Name     :HDOJ2459.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=110000;

/**************SA***********************/

int sa[maxn],Rank[maxn],Rank2[maxn],h[maxn],c[maxn];
int *x,*y;
char str[maxn];

bool cmp(int* r,int a,int b,int l,int n)
{
    if(r[a]==r[b]&&a+l<n&&b+l<n&&r[a+l]==r[b+l]) return true;
    return false;
}

void radix_sort(int n,int sz)
{
    for(int i=0;i<sz;i++) c[i]=0;
    for(int i=0;i<n;i++) c[x[y[i]]]++;
    for(int i=1;i<sz;i++) c[i]+=c[i-1];
    for(int i=n-1;i>=0;i--) sa[--c[x[y[i]]]]=y[i];
}

void get_sa(char c[],int n,int sz=128)
{
    x=Rank,y=Rank2;
    for(int i=0;i<n;i++) x[i]=c[i],y[i]=i;
    radix_sort(n,sz);
    for(int len=1;len<n;len<<=1)
    {
        int yid=0;
        for(int i=n-len;i<n;i++) y[yid++]=i;
        for(int i=0;i<n;i++)
            if(sa[i]>=len) y[yid++]=sa[i]-len;

        radix_sort(n,sz);

        swap(x,y);
        x[sa[0]]=yid=0;

        for(int i=1;i<n;i++)
            x[sa[i]]=cmp(y,sa[i],sa[i-1],len,n)?yid:++yid;

        sz=yid+1;
        if(sz>=n) break;
    }
    for(int i=0;i<n;i++) Rank[i]=x[i];
}

void get_h(char str[],int n)
{
    int k=0; h[0]=0;
    for(int i=0;i<n;i++)
    {
        if(Rank[i]==0) continue;
        k=max(k-1,0);
        int j=sa[Rank[i]-1];
        while(i+k<n&&j+k<n&&str[i+k]==str[j+k]) k++;
        h[Rank[i]]=k;
    }
}

int dp[maxn][22],Log[maxn];

void RMQ_init(int n)
{
    for(int i=0;i<n;i++) dp[i][0]=h[i];
    for(int i=1;i<=Log[n];i++)
    {
        for(int j=0;j+(1<<i)-1<n;j++)
        {
            dp[j][i]=min(dp[j][i-1],dp[j+(1<<(i-1))][i-1]);
        }
    }
}

int lcp(int l,int r)
{
    l=Rank[l],r=Rank[r];
    if(l>r) swap(l,r);
    int a=l+1,b=r;
    int k=Log[b-a+1];
    return min(dp[a][k],dp[b-(1<<k)+1][k]);
}

void pre_init()
{
    Log[0]=-1;
    for(int i=1;i<maxn;i++)
    {
        Log[i]=(i&(i-1))?Log[i-1]:Log[i-1]+1;
    }
}

void Debug(int n)
{
    cout<<"sa: "<<endl;
    putchar(10);
    for(int i=0;i<n;i++)
    {
        printf("%d %s  hight: %d\n",sa[i],str+sa[i],h[i]);
    }
}

/**************SA***********************/

int ans[maxn],an;


int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    pre_init();
    int cas=1;
    while(scanf("%s",str)!=EOF)
    {
        if(str[0]=='#') break;
        int n=strlen(str);

        get_sa(str,n); get_h(str,n); RMQ_init(n);

        int mx=-1;an=0;
        for(int l=1;l<=n-1;l++)
        {
            for(int i=0;i+l<n;i+=l)
            {
                ///公共长度
                int m=lcp(i,i+l);
                ///至少会有r次重复
                int r=m/l+1;
                ///可以尝试往前匹配t
                int t=l-m%l;

                if(i-t>=0&&m%l&&lcp(i-t,i-t+l)>=m) r++;

                if(r>mx)
                {
                    an=0; mx=r;
                    ans[an++]=l;
                }
                else if(r==mx)
                {
                    ans[an++]=l;
                }
            }
        }

        /// 出现mx次所可能的长度
        sort(ans,ans+an);
        an=unique(ans,ans+an)-ans;

        int P=-1,I;
        for(int i=0;i<an&&P==-1;i++)
        {
            int l=ans[i];
            for(int j=0;j<n&&P==-1;j++)
            {
                if(sa[j]+l>=n) continue;
                if(lcp(sa[j],sa[j]+l)>=l*(mx-1))
                {
                    I=ans[i];
                    P=sa[j];
                    break;
                }
            }
        }

        printf("Case %d: ",cas++);
        for(int i=0;i<mx;i++)
        {
            for(int j=0;j<I;j++)
            {
                putchar(str[P+j]);
            }
        }
        putchar(10);

    }
    
    return 0;
}
```

