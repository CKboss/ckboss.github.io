title: HDOJ 5446 Unknown Treasure Lucas+中国剩余定理
date: 2015-09-14 00:22:45
tags:
- China_Remain
- Lucas
categories:
- acm_数论

---

##### 裸题:　Lucas + 中国剩余定理

---

### Unknown Treasure

Time Limit: 1500/1000 MS (Java/Others)    Memory Limit: 131072/131072 K (Java/Others)
Total Submission(s): 495    Accepted Submission(s): 162


#### Problem Description
On the way to the next secret treasure hiding place, the mathematician discovered a cave unknown to the map. The mathematician entered the cave because it is there. Somewhere deep in the cave, she found a treasure chest with a combination lock and some numbers on it. After quite a research, the mathematician found out that the correct combination to the lock would be obtained by calculating how many ways are there to pick m different apples among n of them and modulo it with M. M is the product of several different primes.
 

#### Input
On the first line there is an integer T(T≤20) representing the number of test cases.

Each test case starts with three integers n,m,k(1≤m≤n≤1018,1≤k≤10) on a line where k is the number of primes. Following on the next line are k different primes p1,...,pk. It is guaranteed that M=p1⋅p2⋅⋅⋅pk≤1018 and pi≤105 for every i∈{1,...,k}.
 

#### Output
For each test case output the correct combination on a line.

<!-- more -->
 
```
Sample Input
1
9 5 2
3 5
 

Sample Output
6
```

Source
2015 ACM/ICPC Asia Regional Changchun Online
 

```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月13日 星期日 23时49分22秒
File Name     :HDOJ5446.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

/**********LUCUS*****************/

LL fact[100100];  
  
LL QuickPow(LL x,LL t,LL m)  
{  
    if(t==0) return 1LL;  
    LL e=x,ret=1LL;  
    while(t)  
    {  
        if(t&1) ret=(ret*e)%m;  
        e=(e*e)%m;  
        t>>=1LL;  
    }  
    return ret%m;  
}  
  
void get_fact(LL p)  
{  
    fact[0]=1LL;  
    for(int i=1;i<=p+10;i++)  
        fact[i]=(fact[i-1]*i)%p;  
}  
  
LL Lucas(LL n,LL m,LL p)  
{  
    ///lucas(n,m,p)=c[n%p][m%p]*lucas(n/p,m/p,p);  
	get_fact(p);
    LL ret=1LL;  
    while(n&&m)  
    {  
        LL a=n%p,b=m%p;  
        if(a<b) return 0;  
        ret=(ret*fact[a]*QuickPow((fact[b]*fact[a-b])%p,p-2,p))%p;  
        n/=p; m/=p;  
    }  
    return ret%p;  
}  

/********China remain ********************/

void ex_gcd(LL a,LL b,LL& d,LL &x,LL &y)
{
	if(b==0)
	{
		d=a; x=1; y=0;
	}
	else
	{
		ex_gcd(b,a%b,d,y,x);
		y-=x*(a/b);
	}
}

LL divisor[20],remain[20];

/// m: divisor a: remainder
LL china(LL n,LL* m,LL* a)
{
	LL aa=a[0];
	LL mm=m[0];
	for(int i=0;i<n;i++)
	{
		LL sub=a[i]-aa;

		LL d,x,y;
		ex_gcd(mm,m[i],d,x,y);
		if(sub%d) return -1;

		LL new_m=m[i]/d;
		new_m=(sub/d*x%new_m+new_m)%new_m;

		aa=mm*new_m+aa;
		mm=mm*m[i]/d;
	}
	aa=(aa+mm)%mm;
	return aa;
}

LL n,m,k;

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%lld%lld%lld",&n,&m,&k);
		for(int i=0;i<k;i++)
		{
			LL mod;
			scanf("%lld",&mod);

			remain[i]=Lucas(n,m,mod);
			divisor[i]=mod;
		}
		//for(int i=0;i<k;i++) cout<<divisor[i]<<" "<<remain[i]<<endl;
		LL ans=china(k,divisor,remain);
		printf("%lld\n",ans);
	}
    
    return 0;
}

```
