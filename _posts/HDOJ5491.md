title: HDOJ 5491 The Next 构造
date: 2015-09-30 16:32:21
tags:
- 构造

categories:
- acm_构造

---

> 给一个数D,满足D的二进制里的1在s1和s2之间.
问下一个满足条件的数是多少.

##### 构造题:

由于给出的D是符合条件的,我们从D开始构造出D2,假设这时的D中有L个1,那么我们需要构造出的D2中1的个数至少得为L+1,因为有L个1的数D已经是最小的了.

如何增加一个1并且让D2比D大呢? 我们选择D中最靠近右边的一个0,把这个0变成1.这样D2就可以增加一个1并且比D大了.但是这时的D2并不一定是包含L+1个1中的最小的那个,我们还需要对D2中最右边的0的后面的数进行一次重新排序,把1全部都移动到后面去...

当D中的1的个数L已经比s2大了,这时我们不能再增加1了,需要利用进位把1的个数给减少.如何进位?就是将D加上一个Low_bit(D),这样就可以消除掉一串1.当D中的1<=s2,就继续重复上面的过程,就这样不断的找**增加一个1并且比D大的最小的数**就可以了.

### [The Next](http://acm.hdu.edu.cn/showproblem.php?pid=5491)

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 890    Accepted Submission(s): 369


##### Problem Description
Let L denote the number of 1s in integer D’s binary representation. Given two integers S1 and S2, we call D a WYH number if S1≤L≤S2.
With a given D, we would like to find the next WYH number Y, which is JUST larger than D. In other words, Y is the smallest WYH number among the numbers larger than D. Please write a program to solve this problem.
 

##### Input
The first line of input contains a number T indicating the number of test cases (T≤300000).
Each test case consists of three integers D, S1, and S2, as described above. It is guaranteed that 0 ≤ D < 231 and D is a WYH number.


##### Output
For each test case, output a single line consisting of “Case #X: Y”. X is the test case number starting from 1. Y is the next WYH number.

```txt
Sample Input
3
11 2 4
22 3 3
15 2 5


Sample Output
Case #1: 12
Case #2: 25
Case #3: 17
```

Source
2015 ACM/ICPC Asia Regional Hefei Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月29日 星期二 20时41分43秒
File Name     :HDOJ5491.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <bitset>

using namespace std;

typedef long long int LL;
typedef bitset<40> B4;
LL D;
int s1,s2;

inline LL lowbit(LL x) { return x&(-x); }

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T,cas=1;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%lld%d%d",&D,&s1,&s2);

		D++;
		B4 bit(D);

		while(true)
		{
			int bc=bit.count();
			if(bc>=s1&&bc<=s2)
			{
				printf("Case #%d: %lu\n",cas++,bit.to_ulong());
				break;
			}

			if(bc+1>s2)
			{
				while(bc>s2)
				{
					D+=lowbit(D);
					bit=B4(D);
					bc=bit.count();
				}
			}
			else if(bc+1<=s2)
			{
				/// get smallest number
				/// whose bit is bc+1

				int firstzero=-1;
				int one=0;

				for(int i=0;i<40;i++)
				{
					if(bit[i]==0) 
					{ 
						firstzero=i; 
						bit[i]=1;
						for(int j=0;j<firstzero;j++)
						{
							if(j<one) bit[j]=1;
							else bit[j]=0;
						}
						D=bit.to_ulong();
						bc=bit.count();
						break;
					}
					else one++;
				}
			}
		}
	}

    return 0;
}
```

