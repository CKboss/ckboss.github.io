title: HDOJ 3718 Similarity KM
date: 2015-10-30 23:43:08
tags:
- KM
- 图论
- HDOJ

categories:
- acm_图论

---

裸的KM最大权值匹配

# [Similarity](http://acm.hdu.edu.cn/showproblem.php?pid=3718)

Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 1746    Accepted Submission(s): 688


##### Problem Description
When we were children, we were always asked to do the classification homework. For example, we were given words {Tiger, Panda, Potato, Dog, Tomato, Pea, Apple, Pear, Orange, Mango} and we were required to classify these words into three groups. As you know, the correct classification was {Tiger, Panda, Dog}, {Potato, Tomato, Pea} and {Apple, Pear, Orange, Mango}. We can represent this classification with a mapping sequence{A,A,B,A,B,B,C,C,C,C}, and it means Tiger, Panda, Dog belong to group A, Potato, Tomato, Pea are in the group B, and Apple, Pear, Orange, Mango are in the group C.
But the LABEL of group doesn't make sense and the LABEL is just used to indicate different groups. So the representations {P,P,O,P,O,O,Q,Q,Q,Q} and {E,E,F,E,F,F,W,W,W,W} are equivalent to the original mapping sequence. However, the representations {A,A,A,A,B,B,C,C,C,C} and
{D,D,D,D,D,D,G,G,G,G} are not equivalent.

![](http://acm.hdu.edu.cn/data/images/3718-1.jpg)


The pupils in class submit their mapping sequences and the teacher should read and grade the homework. The teacher grades the homework by calculating the maximum similarity between pupils' mapping sequences and the answer sequence. The definition of similarity is as follow. 

Similarity(S, T) = sum(Si == Ti) / L 
L = Length(S) = Length(T), i = 1, 2,... L,
where sum(Si == Ti) indicates the total number of equal labels in corresponding positions. The maximum similarity means the maximum similarities between S and all equivalent sequences of T, where S is the answer and fixed. Now given all sequences submitted by pupils and the answer sequence, you should calculate the sequences' maximum similarity.
 

##### Input
The input contains multiple test cases. The first line is the total number of cases T (T < 15). The following are T blocks. Each block indicates a case. A case begins with three numbers n (0 < n < 10000), k (0 < k < 27), m (0 < m < 30), which are the total number of objects, groups, and students in the class. The next line consists of n labels and each label is in the range [A...Z]. You can assume that the number of different labels in the sequence is exactly k. This sequence represents the answer. The following are m lines, each line contains n labels and each label also is in the range [A...Z]. These m lines represent the m pupils' answer sequences. You can assume that the number of different labels in each sequence doesn't exceed k.
 

##### Output
For each test case, output m lines, each line is a floating number (Round to 4 digits after the decimal point). You should output the m answers in the order of the sequences appearance.

```
Sample Input
2
10 3 3
A A B A B B C C C C
F F E F E E D D D D
X X X Y Y Y Y Z Z Z
S T R S T R S T R S
3 2 2
A B A
C D C
F F E
 

Sample Output
1.0000
0.7000
0.5000
1.0000
0.6667
```

Author
LIN, Yue
 

Source
2010 Asia Chengdu Regional Contest

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月30日 星期五 22时37分14秒
File Name     :HDOJ3718.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=11111;
const int INF=0x3f3f3f3f;

int n,k,m;
char buff[20];
char g[maxn],a[maxn];

/*        KM          */

int nx=26,ny=26;
int G[30][30];
int linker[30],lx[30],ly[30];
int slack[30];
bool visx[30],visy[30];

bool dfs(int x)
{
    visx[x]=true;
    for(int y=0;y<ny;y++)
    {
        if(visy[y]) continue;
        int tmp=lx[x]+ly[y]-G[x][y];
        if(tmp==0)
        {
            visy[y]=true;
            if(linker[y]==-1||dfs(linker[y]))
            {
                linker[y]=x;
                return true;
            }
        }
        else if(slack[y]>tmp)
            slack[y]=tmp;
    }
    return false;
}

int KM()
{
    memset(linker,-1,sizeof(linker));
    memset(ly,0,sizeof(ly));
    for(int i=0;i<nx;i++)
    {
        lx[i]=-INF;
        for(int j=0;j<ny;j++)
            if(G[i][j]>lx[i]) lx[i]=G[i][j];
    }
    for(int x=0;x<nx;x++)
    {
        for(int i=0;i<ny;i++)
            slack[i]=INF;
        while(true)
        {
            memset(visx,false,sizeof(visx));
            memset(visy,false,sizeof(visy));
            if(dfs(x)) break;
            int d=INF;
            for(int i=0;i<ny;i++)
                if(!visy[i]&&d>slack[i])
                    d=slack[i];
            for(int i=0;i<nx;i++)
                if(visx[i])
                    lx[i]-=d;
            for(int i=0;i<ny;i++)
            {
                if(visy[i]) ly[i]+=d;
                else slack[i]-=d;
            }
        }
    }
    int res=0;
    for(int i=0;i<ny;i++)
        if(linker[i]!=-1)
            res+=G[linker[i]][i];
    return res;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
    while(T_T--)
    {
        scanf("%d%d%d",&n,&k,&m);
        for(int i=0;i<n;i++) { scanf("%s",buff); g[i]=buff[0]; }
        for(int tt=0;tt<m;tt++)
        {
            memset(G,0,sizeof(G));
            for(int i=0;i<n;i++) 
            { 
                scanf("%s",buff); 
                a[i]=buff[0]; 
                G[g[i]-'A'][a[i]-'A']++;
            }
            int km=KM();
            printf("%.4lf\n",(double)km/n);
        }
    }
    
    return 0;
}
```


