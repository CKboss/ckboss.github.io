title: HDOJ 4292 Food 最大流
date: 2015-09-17 15:53:00
tags:
- SAP
- 最大流
categories:
- acm_图论

---

最大流裸题:
* 建图: 人拆点,然后 源点 , 食物 , 人1 , 人2 , 饮料 , 汇点

![建图](http://dl.iteye.com/upload/attachment/0073/8833/c84db2a4-9f00-37b7-ae37-075c5f843d25.jpg)

最近刷题的时候感觉以前的最大流模版速度有点慢,尝试了一下Kuanbin大神的快速SAP,果然名不虚传

### Food

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4146    Accepted Submission(s): 1380


##### Problem Description
　　You, a part-time dining service worker in your college’s dining hall, are now confused with a new problem: serve as many people as possible.
　　The issue comes up as people in your college are more and more difficult to serve with meal: They eat only some certain kinds of food and drink, and with requirement unsatisfied, go away directly.
　　You have prepared F (1 <= F <= 200) kinds of food and D (1 <= D <= 200) kinds of drink. Each kind of food or drink has certain amount, that is, how many people could this food or drink serve. Besides, You know there’re N (1 <= N <= 200) people and you too can tell people’s personal preference for food and drink.
　　Back to your goal: to serve as many people as possible. So you must decide a plan where some people are served while requirements of the rest of them are unmet. You should notice that, when one’s requirement is unmet, he/she would just go away, refusing any service.
 

##### Input
　　There are several test cases.
　　For each test case, the first line contains three numbers: N,F,D, denoting the number of people, food, and drink.
　　The second line contains F integers, the ith number of which denotes amount of representative food.
　　The third line contains D integers, the ith number of which denotes amount of representative drink.
　　Following is N line, each consisting of a string of length F. e jth character in the ith one of these lines denotes whether people i would accept food j. “Y” for yes and “N” for no.
　　Following is N line, each consisting of a string of length D. e jth character in the ith one of these lines denotes whether people i would accept drink j. “Y” for yes and “N” for no.
　　Please process until EOF (End Of File).
 

##### Output
　　For each test case, please print a single line with one integer, the maximum number of people to be satisfied.
  
<!-- more -->
 
```
Sample Input
4 3 3
1 1 1
1 1 1
YYN
NYY
YNY
YNY
YNY
YYN
YYN
NNY
 

Sample Output
3
```

Source
2012 ACM/ICPC Asia Regional Chengdu Online
 

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月17日 星期四 08时19分55秒
File Name     :HDOJ4292.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int INF=0x3f3f3f3f;
const int maxm=1001000;
const int maxn=1005;

struct Edge
{
	int from,to,next;
	int cap;
}edge[maxm];

int Size;
int Adj[maxn],dep[maxn],gap[maxn];

int S,T,N;/// n总点数 

void init()
{
	Size=0; memset(Adj,-1,sizeof(int)*N);
}

void addedge(int u,int v,int w)
{
	edge[Size].from=u; edge[Size].to=v;
	edge[Size].cap=w; edge[Size].next=Adj[u];
	Adj[u]=Size++;

	edge[Size].from=v; edge[Size].to=u;
	edge[Size].cap=0; edge[Size].next=Adj[v];
	Adj[v]=Size++;
}

void BFS(int start,int end)
{
	memset(dep,-1,sizeof(int)*(N+10));
	memset(gap,0,sizeof(int)*(N+10));
	gap[0]=1;
	int que[maxn];
	int front,rear;
	front=rear=0; dep[end]=0;
	que[rear++]=end;
	while(front!=rear)
	{
		int u=que[front++];
		if(front==maxn) front=0;
		for(int i=Adj[u];~i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(dep[v]!=-1) continue;
			que[rear++]=v;
			if(rear==maxn) rear=0;
			dep[v]=dep[u]+1;
			++gap[dep[v]];
		}
	}
}

int SAP(int start,int end)
{
	int res=0;
	BFS(start,end);
	int cur[maxn],S[maxn];
	int top=0,i,u=start;
	memcpy(cur,Adj,sizeof(Adj));

	while(dep[start]<N)
	{
		if(u==end)
		{
			int temp=INF;
			int inser;
			for(int i=0;i<top;i++)
			{
				if(temp>edge[S[i]].cap)
				{
					temp=edge[S[i]].cap;
					inser=i;
				}
			}
			for(int i=0;i<top;i++)
			{
				edge[S[i]].cap-=temp;
				edge[S[i]^1].cap+=temp;
			}
			res+=temp;
			top=inser;
			u=edge[S[top]].from;
		}
		if(u!=end&&gap[dep[u]-1]==0) break;
		for(i=cur[u];~i;i=edge[i].next)
		{
			if(edge[i].cap!=0&&dep[u]==dep[edge[i].to]+1)
				break;
		}
		if(i!=-1)
		{
			cur[u]=i; S[top++]=i; u=edge[i].to;
		}
		else
		{
			int min=N;
			for(i=Adj[u];~i;i=edge[i].next)
			{
				if(edge[i].cap==0) continue;
				if(min>dep[edge[i].to])
				{
					min=dep[edge[i].to];
					cur[u]=i;
				}
			}
			--gap[dep[u]];
			dep[u]=min+1;
			++gap[dep[u]];
			if(u!=start)
				u=edge[S[--top]].from;
		}
	}
	return res;
}

int n,f,d;
char str[300];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d%d%d",&n,&f,&d)!=EOF)
	{
		int BF=2*n;
		int BD=2*n+f;
		S=0; T=2*n+f+d+1; N=T+1;

		init();

		for(int i=1,x;i<=f;i++)
		{
			scanf("%d",&x);
			addedge(S,BF+i,x);
		}
		for(int i=1,x;i<=d;i++)
		{
			scanf("%d",&x);
			addedge(BD+i,T,x);
		}
		for(int i=1;i<=n;i++)
		{
			scanf("%s",str);
			for(int j=1;j<=f;j++)
			{
				if(str[j-1]=='Y')
				{
					addedge(BF+j,i,1);
				}
			}
		}
		for(int i=1;i<=n;i++)
		{
			addedge(i,i+n,1);
			scanf("%s",str);
			for(int j=1;j<=d;j++)
			{
				if(str[j-1]=='Y')
				{
					addedge(i+n,BD+j,1);
				}
			}
		}


		int mf=SAP(S,T);
		printf("%d\n",mf);
	}

    return 0;
}
```