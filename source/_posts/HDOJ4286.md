title: HDOJ 4286 Data Handler Splay
date: 2015-09-12 09:21:46
tags:
- acm_数据结构
- acm
- Splay

categories:
- acm_数据结构

---

插入,删除,翻转等...Splay的基本操作.
唯一的坑点是: 题目中描述的和插图中的操作**基本都是错的**,具体是什么操作得自己去理解....

# 神坑!!!!

<!-- more -->

---
### Data Handler

Time Limit: 20000/10000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2821    Accepted Submission(s): 701


#### Problem Description
　　You are in charge of data in a company, so you are called "Data Handler". Different from the data in computer, the data you have are really in huge volume, and each data contains only one integer. All the data are placed in a line from left to right. There are two "hand" to handle the data, call hand "L" and hand "R". Every hand is between two adjacent data or at the end of the data line.
　　In one day, the company gives you many commands to handle these data, so you should finish them one by one. At the beginning, there are N data, and hand "L" and "R" are in some positions. Each command is one the following formats:
　　(1)MoveLeft L/R: it means that you should move the hand "L"/"R" left one data unit;

![](http://acm.hdu.edu.cn/data/images/C414-1009-1.jpg)

　　(2)MoveRight L/R: it means that you should move the hand "L"/"R" right one data unit;

![](http://acm.hdu.edu.cn/data/images/C414-1009-2.jpg)


　　(3)Insert L X: it means that you should insert the data that contains X at the right of the hand "L";


![](http://acm.hdu.edu.cn/data/images/C414-1009-3.jpg)

　　(4)Insert R X: it means that you should insert the data that contains X at the left of the hand "R";

![](http://acm.hdu.edu.cn/data/images/C414-1009-4.jpg)


　　(5)Delete L: it means that you should delete the one data at the right of the hand "L";

![](http://acm.hdu.edu.cn/data/images/C414-1009-5.jpg)


　　(6)Delete R: it means that you should delete the one data at the left of the hand "R";

![](http://acm.hdu.edu.cn/data/images/C414-1009-6.jpg)


　　(7)Reverse: it means that you should reverse all the data between hand "L" and hand "R".

![](http://acm.hdu.edu.cn/data/images/C414-1009-7.jpg)

　　After finish all the commands, you should record all the data from left to right. So please do it.
 

#### Input
　　The first line contains an integer T(1<=T<=10), the number of test cases.
　　Then T test cases follow. For each test case, the first line contains an integer N(1<=N<=500000), the number of data at the beginning. The second line contains N integers, means the integer in each data, from left to right. The third line contains two integers L and R (1<=L<=R<=N), the positions of hand "L" and hand "R". It means that hand "L" is at the left of the L-th data and hand "R" is at the right of the R-th data. The fourth line contains one integer M(1<=M<=500000), the number of commands. Then M lines follow, each line contains a command in the above format. All the integers in the data will in range [-10000,10000].
　　It is guaranteed that there are always some data between hand "L" and "R", and if the hand is at the left/right end of the data line, it will not receive the command MoveLeft/MoveRight.
　　Because of large input, please use scanf instead of cin.
 

#### Output
　　For each test case, output the integers in the data from left to right in one line, separated in a single space.
　　Because of large output, please use printf instead of cout.
　　
 
```
Sample Input
2
5
1 2 3 4 5
1 5
5
MoveLeft R
Insert R 6
Reverse
Delete R
Insert L 7
5
6536 5207 2609 6604 -4046
1 3
5
Delete L
Insert R -9221
Reverse
Delete L
MoveRight L
 

Sample Output
7 6 4 3 2 5
2609 5207 6604 -4046
```


Source
2012 ACM/ICPC Asia Regional Tianjin Online
 


```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月11日 星期五 21时47分30秒
File Name     :HDOJ4286.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=1000100;
const int INF=0x3f3f3f3f;

#define Key_Value ch[ch[root][1]][0]

int ch[maxn][2],sz[maxn],pre[maxn],key[maxn];
bool rev[maxn];
int root,tot1;

int n,m,a[maxn];

void NewNode(int& x,int father,int k)
{
	x=++tot1;
	ch[x][0]=ch[x][1]=rev[x]=0;
	sz[x]=1; pre[x]=father; key[x]=k;
}

void Erase(int r)
{
	if(r)
	{
		Erase(ch[r][0]);
		Erase(ch[r][1]);
	}
}

void Upd_Rev(int x)
{
	if(!x) return ;
	swap(ch[x][0],ch[x][1]);
	rev[x]^=1;
}

void Push_Up(int x)
{
	sz[x]=sz[ch[x][1]]+sz[ch[x][0]]+1;
}

void Push_Down(int x)
{
	if(rev[x])
	{
		Upd_Rev(ch[x][0]); Upd_Rev(ch[x][1]);
		rev[x]=0;
	}
}

void Build(int& x,int l,int r,int fa)
{
	if(l>r) return ;
	int mid=(l+r)/2;
	NewNode(x,fa,a[mid]);
	Build(ch[x][0],l,mid-1,x);
	Build(ch[x][1],mid+1,r,x);
	Push_Up(x);
}

void Init()
{
	root=tot1=0;
	ch[root][0]=ch[root][1]=pre[root]=sz[root]=0;
	key[root]=INF;
	NewNode(root,0,-INF);
	NewNode(ch[root][1],root,INF);
	Build(Key_Value,1,n,ch[root][1]);
	Push_Up(ch[root][1]);
	Push_Up(root);
}

void Rotate(int x,int kind)
{
	int y=pre[x];
	Push_Down(y);
	Push_Down(x);
	ch[y][!kind]=ch[x][kind];
	pre[ch[x][kind]]=y;
	if(pre[y]) ch[pre[y]][ch[pre[y]][1]==y]=x;
	pre[x]=pre[y];
	pre[y]=x;
	ch[x][kind]=y;
	Push_Up(y);
}

void Splay(int r,int goal)
{
	Push_Down(r);
	while(pre[r]!=goal)
	{
		if(pre[pre[r]]==goal)
		{
			Push_Down(pre[r]);
			Push_Down(r);
			Rotate(r,ch[pre[r]][0]==r);
		}
		else
		{
			Push_Down(pre[pre[r]]);
			Push_Down(pre[r]);
			Push_Down(r);
			int y=pre[r];
			int kind=(ch[pre[y]][0]==y);
			if(ch[y][kind]==r) Rotate(r,!kind);
			else Rotate(y,kind);
			Rotate(r,kind);
		}
	}
	Push_Up(r);
	if(goal==0) root=r;
}

int Get_Kth(int r,int k)
{
	Push_Down(r);
	int t=sz[ch[r][0]]+1;
	if(k==t) return r;
	if(t<k) return Get_Kth(ch[r][1],k-t);
	else return Get_Kth(ch[r][0],k);
}

void REVERSE(int l,int r)
{
	Splay(Get_Kth(root,l),0);
	Splay(Get_Kth(root,r+2),root);
	Upd_Rev(Key_Value);
	Push_Up(ch[root][1]);
	Push_Up(root);
}

void DELETE(int  p)
{
	Splay(Get_Kth(root,p),0);
	Splay(Get_Kth(root,p+2),root);
	Erase(Key_Value);
	pre[Key_Value]=0;
	Key_Value=0;
	Push_Up(ch[root][1]);
	Push_Up(root);
}

void INSERT(int p,int v)
{
	Splay(Get_Kth(root,p+1),0);
	Splay(Get_Kth(root,p+2),root);
	NewNode(Key_Value,ch[root][1],v);
	Push_Up(ch[root][1]);
	Push_Up(root);
}


void PR(int x)
{
	Push_Down(x);
	if(ch[x][0]) PR(ch[x][0]);
	if(key[x]!=INF&&key[x]!=-INF) a[n++]=key[x];
	if(ch[x][1]) PR(ch[x][1]);
}

void show(int x)
{
	Push_Down(x);
	if(ch[x][0]) show(ch[x][0]);
	printf("id: %d size: %d pre: %d left: %d right: %d key: %d\n",x,sz[x],pre[x],ch[x][0],ch[x][1],key[x]);
	if(ch[x][1]) show(ch[x][1]);
}

void DEBUG()
{
	cout<<"............debug............."<<endl;
	show(root);
}

int pl,pr;
char cmd[30];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",a+i);
		scanf("%d%d",&pl,&pr);
		Init();
		scanf("%d",&m);
		while(m--)
		{
			scanf("%s",cmd);
			if((strcmp(cmd,"MoveLeft")==0)||(strcmp(cmd,"MoveRight")==0))
			{
				int k=-1;
				if(strcmp(cmd,"MoveRight")==0) k=1;
				scanf("%s",cmd);
				if(cmd[0]=='L') pl+=k;
				else if(cmd[0]=='R') pr+=k;
			}
			else if(strcmp(cmd,"Insert")==0)
			{
				scanf("%s",cmd);
				int x;
				if(cmd[0]=='L')
				{
					scanf("%d",&x);
					INSERT(pl-1,x); pr++;
				}
				else if(cmd[0]=='R')
				{
					scanf("%d",&x);
					INSERT(pr,x); pr++;
				}
			}
			else if(strcmp(cmd,"Delete")==0)
			{
				scanf("%s",cmd);
				if(cmd[0]=='L')
				{
					DELETE(pl); pr--;
				}
				else if(cmd[0]=='R')
				{
					DELETE(pr); pr--;
				}
			}
			else if(strcmp(cmd,"Reverse")==0)
			{
				REVERSE(pl,pr);
			}
		}
		n=0;
		PR(root);
		for(int i=0;i<n;i++) printf("%d%c",a[i],(i==n-1)?10:32);
	}
    
    return 0;
}

```
