title: ZOJ 2567 Trade 上下界最小流
date: 2015-10-07 10:54:22
tags:
- 网络流
- 上下界

categories:
- acm_图论

---

有一些阿拉伯城市和一些欧洲城市和一些贸易路线,要求满足每个阿拉伯城市和两个欧洲城市之间有贸易路线,每个欧洲城市和俩个阿拉伯城市有贸易路线时的最少可以保留几条贸易路线.

**建图:**
源点到每个阿拉伯城市连容量(2~INF)的边,阿拉伯城市到对应的欧洲城市连容量为1的边,每个欧洲城市往汇点连接容量为(2~INF)的边.

最后按照上下界最小流跑一遍.


### [Trade](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=1567)
Time Limit: 5 Seconds      Memory Limit: 32768 KB      Special Judge

In the Middle Ages m European cities imported many goods from n Arabian cities. Due to continous feudal wars, European cities did not trade with each other, so is some European city needed some Arabian goods, the special trade route was established for this particular trade.

Studying the manuscripts historians have found out that each European city imported goods from at least two Arabian cities, and each Arabian city exported goods to at least two European cities. They have also investigated different factors and identified all potential trade routes (trade routes between some pairs of cities were impossible due to various reasons).

Now historians wonder, what is the minimal possible number of trade routes, that could have existed. Help them to find that out.

#### Input

The first line of the input file contains m, n, and p - the number of European and Arabian cities respectively, and the number of potential trade routes (1 <= m, n <= 300, 1 <= p <= nm). The following p lines describe potential trade routes, each description consists of two numbers - the European and the Arabian city connected by the route.

#### Output

On the first line of the output file print k - the minimal possible number of trade routes that could have existed. After that output k numbers - some minimal set of routes that might have existed to satisfy all conditions. Routes are numbered starting from 1 as they are given in the input file.

If historians must have made a mistake and it is impossible to satisfy the specified conditions, print -1 on the first and the only line of the output file.

```cpp
Sample Input

5 5 14
1 2
1 3
1 4
1 5
2 1
2 5
3 1
3 5
4 1
4 5
5 1
5 2
5 3
5 4
Sample Output

12
1 2 3 5 6 7 8 9 10 12 13 14
```

Author: Andrew Stankevich
Source: Andrew Stankevich's Contest #4

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月07日 星期三 10时15分01秒
File Name     :ZOJ2567.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=1155;
const int maxm=maxn*maxn;
const int INF=0x3f3f3f3f;

struct Edge
{
	int to,next,cap,flow;
}edge[maxm];

int Size,Adj[maxn];
int gap[maxn],dep[maxn],pre[maxn],cur[maxn];

void init() { Size=0; memset(Adj,-1,sizeof(Adj)); }

void addedge(int u,int v,int w,int rw=0)
{
	edge[Size].to=v; edge[Size].cap=w; edge[Size].next=Adj[u]; edge[Size].flow=0; Adj[u]=Size++;
	edge[Size].to=u; edge[Size].cap=rw; edge[Size].next=Adj[v]; edge[Size].flow=0; Adj[v]=Size++;
}

int sap(int start,int end,int N)
{
	memset(gap,0,sizeof(gap));
	memset(dep,0,sizeof(dep));
	memcpy(cur,Adj,sizeof(Adj));

	int u=start;
	pre[u]=-1; gap[0]=N;
	int ans=0;

	while(dep[start]<N)
	{
		if(u==end)
		{
			int Min=INF;
			for(int i=pre[u];~i;i=pre[edge[i^1].to])
			{
				if(Min>edge[i].cap-edge[i].flow)
				{
					Min=edge[i].cap-edge[i].flow;
				}
			}
			for(int i=pre[u];~i;i=pre[edge[i^1].to])
			{
				edge[i].flow+=Min;
				edge[i^1].flow-=Min;
			}
			u=start;
			ans+=Min;
			continue;
		}
		bool flag=false;
		int v;
		for(int i=cur[u];~i;i=edge[i].next)
		{
			v=edge[i].to;
			if(edge[i].cap-edge[i].flow&&dep[v]+1==dep[u])
			{
				flag=true;
				cur[u]=pre[v]=i;
				break;
			}
		}
		if(flag)
		{
			u=v; continue;
		}
		int Min=N;
		for(int i=Adj[u];~i;i=edge[i].next)
		{
			if(edge[i].cap-edge[i].flow&&dep[edge[i].to]<Min)
			{
				Min=dep[edge[i].to];
				cur[u]=i;
			}
		}
		gap[dep[u]]--;
		if(!gap[dep[u]]) return ans;
		dep[u]=Min+1;
		gap[dep[u]]++;
		if(u!=start) u=edge[pre[u]^1].to;
	}
	return ans;
}

int S,T,s,t,N;
int n1,n2,m;
int in[maxn];
vector<int> es;

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d%d%d",&n1,&n2,&m)!=EOF)
	{
		init(); memset(in,0,sizeof(in)); es.clear();
		for(int i=0,u,v;i<m;i++)
		{
			scanf("%d%d",&u,&v);
			addedge(u,v+n1,1);
			es.push_back(Size-2);
		}
		s=0; t=n1+n2+1;
		S=t+1; T=S+1; N=T+1;
		for(int i=1;i<=n1;i++)
		{
			addedge(s,i,INF);
			in[s]-=2; in[i]+=2;
		}
		for(int i=n1+1;i<=n1+n2;i++)
		{
			addedge(i,t,INF);
			in[i]-=2; in[t]+=2;
		}
		int sum=0;
		for(int i=s;i<=t;i++)
		{
			if(in[i]>0)
			{
				sum+=in[i];
				addedge(S,i,in[i]);
			}
			if(in[i]<0)
			{
				addedge(i,T,-in[i]);
			}
		}
		int mf1=sap(S,T,N);
		addedge(t,s,INF);
		int mf2=sap(S,T,N);
		if(mf1+mf2==sum)
		{
			printf("%d\n",edge[Size-2].flow);
			for(int i=0;i<m;i++)
			{
				int id=es[i];
				if(edge[id].flow!=0) printf("%d ",i+1);
			}
			putchar(10);
		}
		else
		{
			puts("-1");
		}
	}

    return 0;
}
```