title: CodeForces 592D. Super M 树的直径+树DP

date: 2015-11-07 20:19:37

tags:
- dp
- 树

categories:
- acm_dp

---

##### 题目大意:
给一棵树,和树上的一些需要到达的点,你可以选择一个点为起点,沿着树到达其他需要到达的点.问所需走的最小距离是多少.

##### 解:
设一个最小子树T包含了所有需要到达的点,则所需要走的最小距离是T的边数和减去T的直径.T可以由树形DP求得.

# [D. Super M](http://codeforces.com/problemset/problem/592/D)
time limit per test2 seconds
memory limit per test256 megabytes
inputstandard input
outputstandard output


Ari the monster is not an ordinary monster. She is the hidden identity of Super M, the Byteforces’ superhero. Byteforces is a country that consists of n cities, connected by n - 1 bidirectional roads. Every road connects exactly two distinct cities, and the whole road system is designed in a way that one is able to go from any city to any other city using only the given roads. There are m cities being attacked by humans. So Ari... we meant Super M have to immediately go to each of the cities being attacked to scare those bad humans. Super M can pass from one city to another only using the given roads. Moreover, passing through one road takes her exactly one kron - the time unit used in Byteforces.

![](http://codeforces.com/predownloaded/c1/cd/c1cdef520cd33dff0147d2448dc127d9dbe51bab.png)

However, Super M is not on Byteforces now - she is attending a training camp located in a nearby country Codeforces. Fortunately, there is a special device in Codeforces that allows her to instantly teleport from Codeforces to any city of Byteforces. The way back is too long, so for the purpose of this problem teleportation is used exactly once.

You are to help Super M, by calculating the city in which she should teleport at the beginning in order to end her job in the minimum time (measured in krons). Also, provide her with this time so she can plan her way back to Codeforces.

Input
The first line of the input contains two integers n and m (1 ≤ m ≤ n ≤ 123456) - the number of cities in Byteforces, and the number of cities being attacked respectively.

Then follow n - 1 lines, describing the road system. Each line contains two city numbers ui and vi (1 ≤ ui, vi ≤ n) - the ends of the road i.

The last line contains m distinct integers - numbers of cities being attacked. These numbers are given in no particular order.

##### Output
First print the number of the city Super M should teleport to. If there are many possible optimal answers, print the one with the lowest city number.

Then print the minimum possible time needed to scare all humans in cities being attacked, measured in Krons.

Note that the correct answer is always unique.

```
Sample test(s)
input
7 2
1 2
1 3
1 4
3 5
3 6
3 7
2 7
output
2
3
input
6 4
1 2
2 3
2 4
4 5
4 6
2 4 5 6
output
2
4
```

##### Note
In the first sample, there are two possibilities to finish the Super M's job in 3 krons. They are:
![](http://codeforces.com/predownloaded/d2/93/d2937a782c97699c7ee0c44ffe9dd93b024e10ad.png)
 and ![](http://codeforces.com/predownloaded/8c/45/8c453032b41dfd118adc07af9c84934cd44aa1e9.png) .

However, you should choose the first one as it starts in the city with the lower number.

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月07日 星期六 16时54分08秒
File Name     :CF592D.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=133456;

int n,m;

int checkpoint[maxn];
bool VIP[maxn];

struct Edge
{
    int to,next,cost;
}edge[maxn*2];

int Adj[maxn],Size;

void init()
{
    memset(Adj,-1,sizeof(Adj)); Size=0;
}

void Add_Edge(int u,int v)
{
    edge[Size].to=v;
    edge[Size].next=Adj[u];
    edge[Size].cost=1;
    Adj[u]=Size++;
}

int dist[maxn];
bool inq[maxn];

void spfa(int root)
{
    memset(dist,63,sizeof(dist));
    memset(inq,false,sizeof(inq));

    dist[root]=0;
    queue<int> q;
    inq[root]=true; q.push(root);

    while(!q.empty())
    {
        int u=q.front(); q.pop();
        for(int i=Adj[u];~i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(dist[v]>dist[u]+edge[i].cost)
            {
                dist[v]=dist[u]+edge[i].cost;
                if(!inq[v])
                {
                    inq[v]=true;
                    q.push(v);
                }
            }
        }
        inq[u]=false;
    }
}

int PTS;

bool dfs(int u,int fa)
{
    bool cnt=VIP[u];

    for(int i=Adj[u];~i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v==fa) continue;

        if(dfs(v,u)==true) cnt=true;
    }
    if(cnt==true) PTS++;
    return cnt;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    init();
    scanf("%d%d",&n,&m);
    for(int i=0,x,y;i<n-1;i++)
    {
        scanf("%d%d",&x,&y);
        Add_Edge(x,y); Add_Edge(y,x);
    }
    for(int i=0;i<m;i++) 
    {
        scanf("%d",checkpoint+i);
        VIP[checkpoint[i]]=true;
    }
    sort(checkpoint,checkpoint+m);

    int mx=checkpoint[0];
    spfa(mx);

    for(int i=0;i<m;i++)
    {
        int v=checkpoint[i];
        if(dist[v]>dist[mx]) mx=v;
    }

    spfa(mx);
    mx=checkpoint[0];

    PTS=0;
    dfs(mx,mx);

    for(int i=0;i<m;i++)
    {
        int v=checkpoint[i];
        /// 找距离最远的点
        if(dist[mx]<dist[v]) mx=v;
    }

    int ans=mx;
    for(int i=0;i<m;i++)
    {
        int v=checkpoint[i];
        /// 找可能的直径的端点
        if(dist[v]==dist[mx]||dist[v]==0) ans=min(ans,v);
    }

    printf("%d\n%d\n",ans,(PTS-1)*2-dist[mx]);
    
    return 0;
}
```