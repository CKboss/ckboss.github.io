title: HDOJ 4126 Genghis Khan the Conqueror 次小生成树

date: 2015-11-07 12:31:50

tags:
- 次小生成树

categories:
- acm_图论


---

**次小生成树:**

次小生成树的另外一种求法,同样先求出MST,然后用树形DP求出如果切除MST上$i,j$之间的边,所形成的两个联通块之间的最短的边的值 $dp[i][j]$.

$dp[i][j]$可以用树形dp求得,既枚举一个树根P,对于每条边 $u \rightarrow v$ ,我们用v到P的距离来更新$dp[u][v]$的值,伪代码如下:

```python
dfs(P,u,fa,deepth):

	if deepth==1 :
		ret=INF
	else:
		ret=Edge(u,P)

	for v every point connect of u :
		if v==fa:
			continue
		else :
			ti = dfs(P,v,u,deepth+1)
			ret = min(ret,ti)
			dp[u][v]=dp[v][u]=min(ti,dp[v][u])

	return ti
```

如果用Prime的MST,整体的时间复杂度为:　$O(v^2)$

# Genghis Khan the Conqueror

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 327680/327680 K (Java/Others)
Total Submission(s): 2128    Accepted Submission(s): 628


##### Problem Description
Genghis Khan(成吉思汗)(1162-1227), also known by his birth name Temujin(铁木真) and temple name Taizu(元太祖), was the founder of the Mongol Empire and the greatest conqueror in Chinese history. After uniting many of the nomadic tribes on the Mongolian steppe, Genghis Khan founded a strong cavalry equipped by irony discipline, sabers and powder, and he became to the most fearsome conqueror in the history. He stretched the empire that resulted in the conquest of most of Eurasia. The following figure (origin: Wikipedia) shows the territory of Mongol Empire at that time.

![](http://acm.hdu.edu.cn/data/images/4126-1.jpg)

Our story is about Jebei Noyan(哲别), who was one of the most famous generals in Genghis Khan’s cavalry. Once his led the advance troop to invade a country named Pushtuar. The knights rolled up all the cities in Pushtuar rapidly. As Jebei Noyan’s advance troop did not have enough soldiers, the conquest was temporary and vulnerable and he was waiting for the Genghis Khan’s reinforce. At the meantime, Jebei Noyan needed to set up many guarders on the road of the country in order to guarantee that his troop in each city can send and receive messages safely and promptly through those roads.

There were N cities in Pushtuar and there were bidirectional roads connecting cities. If Jebei set up guarders on a road, it was totally safe to deliver messages between the two cities connected by the road. However setting up guarders on different road took different cost based on the distance, road condition and the residual armed power nearby. Jebei had known the cost of setting up guarders on each road. He wanted to guarantee that each two cities can safely deliver messages either directly or indirectly and the total cost was minimal.

Things will always get a little bit harder. As a sophisticated general, Jebei predicted that there would be one uprising happening in the country sooner or later which might increase the cost (setting up guarders) on exactly ONE road. Nevertheless he did not know which road would be affected, but only got the information of some suspicious road cost changes. We assumed that the probability of each suspicious case was the same. Since that after the uprising happened, the plan of guarder setting should be rearranged to achieve the minimal cost, Jebei Noyan wanted to know the new expected minimal total cost immediately based on current information.
 

##### Input
There are no more than 20 test cases in the input. 
For each test case, the first line contains two integers N and M (1<=N<=3000, 0<=M<=N×N), demonstrating the number of cities and roads in Pushtuar. Cities are numbered from 0 to N-1. In the each of the following M lines, there are three integers xi, yi and ci(ci<=107), showing that there is a bidirectional road between xi and yi, while the cost of setting up guarders on this road is ci. We guarantee that the graph is connected. The total cost of the graph is less or equal to 109.

The next line contains an integer Q (1<=Q<=10000) representing the number of suspicious road cost changes. In the following Q lines, each line contains three integers Xi, Yi and Ci showing that the cost of road (Xi, Yi) may change to Ci (Ci<=107). We guarantee that the road always exists and Ci is larger than the original cost (we guarantee that there is at most one road connecting two cities directly). Please note that the probability of each suspicious road cost change is the same.


##### Output
For each test case, output a real number demonstrating the expected minimal total cost. The result should be rounded to 4 digits after decimal point.

```
Sample Input
3 3
0 1 3
0 2 2
1 2 5
3
0 2 3
1 2 6
0 1 6
0 0
 

Sample Output
6.0000
```

##### Hint

The initial minimal cost is 5 by connecting city 0 to 1 and city 0 to 2. In the first suspicious case, the minimal total cost is increased to 6;
 the second case remains 5; the third case is increased to 7. As the result, the expected cost is (5+6+7)/3 = 6.

##### Source
2011 Asia Fuzhou Regional Contest

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月07日 星期六 09时49分48秒
File Name     :HDOJ4126.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=3030;
const int INF=0x3f3f3f3f;

bool onTree[maxn][maxn];
int G[maxn][maxn];

struct EE
{
    int u,v,c;
};

int n,m,Q;
vector<EE> ve;
vector<int> Graph[maxn];

void init()
{
    memset(onTree,false,sizeof(onTree));
    memset(G,63,sizeof(G));
    for(int i=0;i<n+10;i++) Graph[i].clear();
    ve.clear();
}

/// prime

int dist[maxn];
int pre[maxn];
bool vis[maxn];

int MST_prime()
{
    memset(dist,63,sizeof(dist));
    memset(vis,false,sizeof(vis));

    dist[0]=0;
    for(int i=0;i<n;i++) pre[i]=-1;

    int ret=0;
    for(int _=0;_<n;_++)
    {
        int mark=-1,len=INF;
        for(int i=0;i<=n;i++)
        {
            if(vis[i]==false&&dist[i]<len)
            {
                len=dist[i]; mark=i;
            }
        }

        if(mark==-1) return INF;
        vis[mark]=true; ret+=len;

        for(int i=0;i<n;i++)
        {
            if(vis[i]==false&&dist[i]>G[mark][i])
            {
                dist[i]=G[mark][i]; pre[i]=mark;
            }
        }
    }

    for(int i=0;i<n;i++)
    {
        int j=pre[i];
        if(j==-1) continue;
        onTree[i][j]=onTree[j][i]=true;
        Graph[i].push_back(j);
        Graph[j].push_back(i);
    }
    return ret;
}

int dp[maxn][maxn];

int dfs(int P,int u,int fa,int deep)
{
    int ret=INF; 
    if(deep!=1) ret=G[u][P];
    for(int i=0,sz=Graph[u].size();i<sz;i++)
    {
        int v=Graph[u][i];
        if(v==fa) continue;

        int tt=dfs(P,v,u,deep+1);
        ret=min(ret,tt);

        dp[u][v]=dp[v][u]=min(dp[u][v],tt);
    }
    return ret;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    while(scanf("%d%d",&n,&m)!=EOF)
    {
        if(n==0&&m==0) break;

        init();
        for(int i=0,u,v,c;i<m;i++)
        {
            scanf("%d%d%d",&u,&v,&c);
            G[u][v]=G[v][u]=c;
            ve.push_back((EE){u,v,c});
        }
        int mst=MST_prime();

        memset(dp,63,sizeof(dp));
        for(int i=0;i<n;i++) dfs(i,i,-1,0);
        
        double sum=0;
        scanf("%d",&Q);
        double tQ=Q;
        while(Q--)
        {
            int u,v,c;
            scanf("%d%d%d",&u,&v,&c);
            int nmst=0;
            if(onTree[u][v]==false) nmst+=mst;
            else
            {
                int deta=min(dp[u][v],c)-G[u][v];
                nmst=mst+deta;
            }
            sum+=nmst;
        }
        printf("%.4lf\n",sum/tQ);
    }

    return 0;
}
```