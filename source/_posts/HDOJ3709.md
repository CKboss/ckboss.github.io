title: HDOJ 3709 Balanced Number 枚举+数位DP
date: 2015-10-31 10:54:40
tags:
- 数位dp
- 枚举

categories:
- acm_dp

---

枚举轴的位置,然后数位dp

# [Balanced Number](http://acm.hdu.edu.cn/showproblem.php?pid=3709)

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 65535/65535 K (Java/Others)
Total Submission(s): 3099    Accepted Submission(s): 1423


##### Problem Description
A balanced number is a non-negative integer that can be balanced if a pivot is placed at some digit. More specifically, imagine each digit as a box with weight indicated by the digit. When a pivot is placed at some digit of the number, the distance from a digit to the pivot is the offset between it and the pivot. Then the torques of left part and right part can be calculated. It is balanced if they are the same. A balanced number must be balanced with the pivot at some of its digits. For example, 4139 is a balanced number with pivot fixed at 3. The torqueses are 4*2 + 1*1 = 9 and 9*1 = 9, for left part and right part, respectively. It's your job
to calculate the number of balanced numbers in a given range [x, y].
 

##### Input
The input contains multiple test cases. The first line is the total number of cases T (0 < T ≤ 30). For each case, there are two integers separated by a space in a line, x and y. (0 ≤ x ≤ y ≤ 1018).
 

##### Output
For each case, print the number of balanced numbers in the range [x, y] in a line.

```
Sample Input
2
0 9
7604 24324
 

Sample Output
10
897
```

Author
GAO, Yuan
 

Source
2010 Asia Chengdu Regional Contest

<!--more-->


```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月31日 星期六 10时12分03秒
File Name     :HDOJ3709.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

LL c[30],cnt;
LL dp[30][30][3000];

LL dfs(LL pos,LL axle,LL sum,bool limit)
{
    if(pos==-1) return (sum==0)?1:0;
    if(limit==false&&dp[pos][axle][sum]!=-1) 
        return dp[pos][axle][sum];
    LL mx=(limit==true)?c[pos]:9;
    LL ret=0;
    for(LL i=0;i<=mx;i++)
    {
        ret+=dfs(pos-1,axle,sum+(pos-axle)*i,(i==mx)&&limit);
    }
    if(limit==false) dp[pos][axle][sum]=ret;
    return ret;
}

void fj(LL x)
{
    cnt=0;
    while(x) { c[cnt++]=x%10; x/=10; }
}

LL solve(LL x)
{
    if(x<0) return 0;
    if(x==0) return 1;
    fj(x);
    LL ans=0;
    for(LL i=0;i<cnt;i++)
        ans+=dfs(cnt-1,i,0,true);
    return ans-cnt+1;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    memset(dp,-1,sizeof(dp));
    LL T_T;
    cin>>T_T;
    while(T_T--)
    {
        LL a,b;
        cin>>a>>b;
        cout<<solve(b)-solve(a-1)<<endl;
    }

    return 0;
}
```