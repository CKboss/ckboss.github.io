title: HDOJ 4279 Number 找规律
date: 2015-09-12 10:02:27
tags: 
- 坑

categories:
- acm_想法技巧

---

打表找规律即可,符合条件的数都是偶数但是会加减一些奇数或偶数的平方

但是数据范围太大.在HDOJ换编译器后会产生精度误差,无论如何都过不了....只能用java写了.

## 坑题的一种!!!!

<!-- more -->

---

### Number

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4406    Accepted Submission(s): 1089


##### Problem Description
　　Here are two numbers A and B (0 < A <= B). If B cannot be divisible by A, and A and B are not co-prime numbers, we define A as a special number of B.
　　For each x, f(x) equals to the amount of x’s special numbers.
　　For example, f(6)=1, because 6 only have one special number which is 4. And f(12)=3, its special numbers are 8,9,10.
　　When f(x) is odd, we consider x as a real number.
　　Now given 2 integers x and y, your job is to calculate how many real numbers are between them.
 

##### Input
　　In the first line there is an integer T (T <= 2000), indicates the number of test cases. Then T line follows, each line contains two integers x and y (1 <= x <= y <= 2^63-1) separated by a single space.
 

##### Output
　　Output the total number of real numbers.
 
```
Sample Input
2
1 1
1 10
 

Sample Output
0
4
```

Hint
 For the second case, the real numbers are 6,8,9,10. 
 
 

Source
2012 ACM/ICPC Asia Regional Tianjin Online
 
```java
import java.util.*;
import java.math.*;

public class Main
{
    BigInteger find_MX(BigInteger x)
    {
        BigInteger low=BigInteger.ONE;
        BigInteger high=x;
        BigInteger ans=BigInteger.ONE;
        
        while(low.compareTo(high)<=0)
        {
            BigInteger mid=(low.add(high)).divide(BigInteger.valueOf(2));
            if(mid.multiply(mid).compareTo(x)<=0)
            {
                ans=mid;
                low=mid.add(BigInteger.ONE);
            }
            else
            {
                high=mid.subtract(BigInteger.ONE);
            }
        }
        
        return ans;
    }
    
    BigInteger solve(BigInteger x)
    {
        if(x.compareTo(BigInteger.ONE)<=0)
            return BigInteger.ZERO;
        BigInteger pfs=find_MX(x);
        BigInteger o_pf=pfs.divide(BigInteger.valueOf(2));
        BigInteger j_pf=pfs.subtract(o_pf);
        
        return x.divide(BigInteger.valueOf(2)).subtract(o_pf).add(j_pf).subtract(BigInteger.valueOf(2));
    }
    
    Main()
    {
        Scanner in = new Scanner(System.in);
        int T_T=in.nextInt();
        while(T_T-->0) {
            BigInteger l = in.nextBigInteger();
            BigInteger r = in.nextBigInteger();
            
            System.out.println(solve(r).subtract(solve(l.subtract(BigInteger.ONE))));
        }
    }
    
    public static void main(String[] args)
    {
        new Main();
    }
}
```
