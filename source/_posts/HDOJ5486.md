title: HDOJ 5486 Difference of Clustering 模拟
date: 2015-09-29 10:58:37
tags:
- 模拟
categories:
- acm_模拟

---

给两个集合,之间会有1:n,n:1,1:1,n:n的对应关系,问除了n:n外各有多少种...

*总是感觉题意比较模糊...*

本质上就一道模拟题:

1. 先离散化一下
2. 所谓1:n的关系就是,与左边集合X有关系的右边那几个集合都仅仅只和X有关系. 从右边向左边考虑就是n:1的关系. 注意要特判1:1这种特殊的情况.


### Difference of Clustering

Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 272    Accepted Submission(s): 90


##### Problem Description
Given two clustering algorithms, the old and the new, you want to find the difference between their results. 
A clustering algorithm takes many member entities as input and partition them into clusters. In this problem, a member entity must be clustered into exactly one cluster. However, we don’t have any pre-knowledge of the clusters, so different algorithms may produce different number of clusters as well as different cluster IDs. One thing we are sure about is that the memberIDs are stable, which means that the same member ID across different algorithms indicates the same member entity.
To compare two clustering algorithms, we care about three kinds of relationship between the old clusters and the new clusters: split, merge and 1:1. Please refer to the figure below.

![](http://acm.hdu.edu.cn/data/images/C624-1003-1.jpg)

Let’s explain them with examples. Say in the old result, m0, m1, m2 are clustered into one cluster c0, but in the new result, m0 and m1 are clustered into c0, but m2 alone is clustered into c1. We denote the relationship like the following:
●  In the old, c0 = [m0, m1, m2]
●  In the new, c0 = [m0, m1], c1 = [m2]
There is no other members in the new c0 and c1. Then we say the old c0 is split into new c0 and new c1. A few more examples:
●  In the old, c0 = [m0, m1, m2]
●  In the new, c0 = [m0, m1, m2]. 
This is 1:1.
●  In the old, c0 = [m0, m1], c1 = [m2]
●  In the new, c0 = [m0, m1, m2]
This is merge. Please note, besides these relationship, there is another kind called “n:n”:
●  In the old, c0 = [m0, m1], c1 = [m2, m3]
●  In the new, c0 = [m0, m1, m2], c1 = [m3]
We don’t care about n:n. 
In this problem, we will give you two sets of clustering results, each describing the old and the new. We want to know the total number of splits, merges, and 1:1 respectively.

 

#####Input
The first line of input contains a number T indicating the number of test cases (T≤100).
Each test case starts with a line containing an integer N indicating the number of member entities (0≤N≤106 ). In the following N lines, the i-th line contains two integers c1 and c2, which means that the member entity with ID i is partitioned into cluster c1 and cluster c2 by the old algorithm and the new algorithm respectively. The cluster IDs c1 and c2 can always fit into a 32-bit signed integer.
 

##### Output
For each test case, output a single line consisting of “Case #X: A B C”. X is the test case number starting from 1. A, B, and C are the numbers of splits, merges, and 1:1s.
 
```
Sample Input
2
3
0 0
0 0
0 1
4
0 0
0 0
1 1
1 1
 

Sample Output
Case #1: 1 0 0
Case #2: 0 0 2
```

Source
2015 ACM/ICPC Asia Regional Hefei Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月29日 星期二 08时24分17秒
File Name     :HDOJ5486.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=1001000;

int m,n;
int all[maxn*2];
int Lside[maxn],Rside[maxn];
int cnts[maxn*2];
int fa[maxn*2];
bool isOK[maxn*2];
int no,on,oo,oo1,oo2;

void CLEAR()
{
	for(int i=0;i<=m+10;i++) 
	{
		cnts[i]=0; isOK[i]=true; fa[i]=0;
	}
}

struct LR
{
	int l,r;
	bool operator<(const LR& lr) const
	{
		if(l!=lr.l) return l<lr.l;
		return r<lr.r;
	}
	bool operator==(const LR& lr) const
	{
		return (l==lr.l)&&(r==lr.r);
	}
};

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T,cas=1;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		m=0;
		for(int i=0;i<n;i++)
		{
			scanf("%d%d",Lside+i,Rside+i);
			all[m++]=Lside[i];
			all[m++]=Rside[i];
		}
		sort(all,all+m);
		m=unique(all,all+m)-all;

		vector<LR> vivi;

		for(int i=0;i<n;i++)
		{
			int L=lower_bound(all,all+m,Lside[i])-all+1;
			int R=lower_bound(all,all+m,Rside[i])-all+1;
			vivi.push_back((LR){L,R});
		}

		sort(vivi.begin(),vivi.end());
		n=unique(vivi.begin(),vivi.end())-vivi.begin();

		for(int i=0;i<n;i++)
		{
			Lside[i]=vivi[i].l;
			Rside[i]=vivi[i].r;
		}

		/***********solve it********************/
		no=0,on=0,oo=0;
		oo1=oo2=0;

		CLEAR();

		for(int i=0;i<n;i++) 
		{
			cnts[Rside[i]]++;
			if(fa[Lside[i]]==0)
			{
				fa[Lside[i]]=Rside[i];
			}
			else if(fa[Lside[i]]!=Rside[i])
			{
				fa[Lside[i]]=-1;
			}
		}

		for(int i=0;i<n;i++)
		{
			if(cnts[Rside[i]]>=2) 
				isOK[Lside[i]]=false;
		}
		for(int i=0;i<n;i++) 
		{
			int id=Lside[i];
			if(isOK[id]) 
			{
				isOK[id]=false; on++;
				if(fa[id]!=-1) oo1++;
			}
		}

		CLEAR();
		for(int i=0;i<n;i++) 
		{
			cnts[Lside[i]]++;
			if(fa[Rside[i]]==0)
			{
				fa[Rside[i]]=Lside[i];
			}
			else if(fa[Rside[i]]!=Lside[i])
			{
				fa[Rside[i]]=-1;
			}
		}
		for(int i=0;i<n;i++)
		{
			if(cnts[Lside[i]]>=2)
				isOK[Rside[i]]=false;
		}
		for(int i=0;i<n;i++)
		{
			int id=Rside[i];
			if(isOK[id]) 
			{
				isOK[id]=false; no++;
			}
		}

		on-=oo1; no-=oo1;
		oo=oo1;

		printf("Case #%d: %d %d %d\n",cas++,on,no,oo);
	}
    
    return 0;
}

```


