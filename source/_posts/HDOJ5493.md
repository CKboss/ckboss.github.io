title: HDOJ 5493 Queue 树状数组+二分
date: 2015-10-02 17:37:13
tags:
- acm
- 树装数组
- 二分
categories:
- acm_数据结构

---

从低的向高的考虑,用一个树状数组维护每个位置之前有多少个位置已经被占了. 那么对第i个人,二分求出从开头或者结尾找到第k个空位时的位置$p1\ and\ p2$.第i个人所在的位置应该是$min(p1,p2)$,如果找不到了,那么就是impossible

### Queue

Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 551    Accepted Submission(s): 295


##### Problem Description
N people numbered from 1 to N are waiting in a bank for service. They all stand in a queue, but the queue never moves. It is lunch time now, so they decide to go out and have lunch first. When they get back, they don’t remember the exact order of the queue. Fortunately, there are some clues that may help.
Every person has a unique height, and we denote the height of the i-th person as hi. The i-th person remembers that there were ki people who stand before him and are taller than him. Ideally, this is enough to determine the original order of the queue uniquely. However, as they were waiting for too long, some of them get dizzy and counted ki in a wrong direction. ki could be either the number of taller people before or after the i-th person.
Can you help them to determine the original order of the queue?
 

##### Input
The first line of input contains a number T indicating the number of test cases (T≤1000).
Each test case starts with a line containing an integer N indicating the number of people in the queue (1≤N≤100000). Each of the next N lines consists of two integers hi and ki as described above (1≤hi≤109,0≤ki≤N−1). Note that the order of the given hi and ki is randomly shuffled.
The sum of N over all test cases will not exceed 106
 

##### Output
For each test case, output a single line consisting of “Case #X: S”. X is the test case number starting from 1. S is people’s heights in the restored queue, separated by spaces. The solution may not be unique, so you only need to output the smallest one in lexicographical order. If it is impossible to restore the queue, you should output “impossible” instead.

```cpp
Sample Input
3
3
10 1
20 1
30 0
3
10 0
20 1
30 0
3
10 0
20 0
30 1
 

Sample Output
Case #1: 20 10 30
Case #2: 10 20 30
Case #3: impossible
```

##### Source
2015 ACM/ICPC Asia Regional Hefei Online

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月02日 星期五 14时31分25秒
File Name     :HDOJ5493.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=101000;
const int INF=0x3f3f3f3f;

int n;
struct People
{
	int high,k;
}peo[maxn];
bool cmp(People a,People b) { return a.high<b.high; }

inline int lowbit(int x) { return x&(-x); }
int tree[maxn];

void Add(int p)
{
	for(int i=p;i<=n;i+=lowbit(i)) tree[i]+=1;
}

int Sum(int p)
{
	int ret=0;
	for(int i=p;i;i-=lowbit(i)) ret+=tree[i];
	return ret;
}

int a[maxn];

int BinSerach(int kth)
{
	int low=1,high=n,mid;
	int ret=INF;

	while(low<=high)
	{
		int mid=(low+high)/2;
		int nub=mid-Sum(mid);

		if(nub==kth) ret=mid;
		if(nub<kth) low=mid+1;
		else if(nub>=kth) high=mid-1;
	}

	return ret;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
	
	int cas=1,T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		for(int i=0;i<n;i++) { scanf("%d%d",&peo[i].high,&peo[i].k); }
		sort(peo,peo+n,cmp);

		for(int i=0;i<=n+10;i++) { a[i]=tree[i]=0; }

		bool Flag=true;
		for(int i=0;i<n&&Flag;i++)
		{
			int K=peo[i].k;

			/// find first Pos from head
			int p1 = BinSerach(K+1);

			/// find second Pos from tail
			int p2 = BinSerach(n-i-K);
			int pos=min(p1,p2);

			if(pos!=INF)
			{
				if(a[pos]==0)
				{
					a[pos]=peo[i].high;
					Add(pos);
				}
				else { Flag=false; break; }
			}
			else { Flag=false; break; }
		}

		if(Flag==false) printf("Case #%d: impossible\n",cas++);
		else
		{
			printf("Case #%d:",cas++);
			for(int i=1;i<=n;i++) printf(" %d",a[i]);
			putchar(10);
		}

	}
    
    return 0;
}
```
