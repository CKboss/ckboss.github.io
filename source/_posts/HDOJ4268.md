title: HDOJ 4268 Alice and Bob 贪心
date: 2015-09-07 19:10:54
tags: 
- acm_贪心
- acm
categories: 
- acm_贪心
---

按x和y排序后,贪心从y大的覆盖
用mulitset维护下即可....

***

#### Alice and Bob

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 3817    Accepted Submission(s): 1198


Problem Description
Alice and Bob's game never ends. Today, they introduce a new game. In this game, both of them have N different rectangular cards respectively. Alice wants to use his cards to cover Bob's. The card A can cover the card B if the height of A is not smaller than B and the width of A is not smaller than B. As the best programmer, you are asked to compute the maximal number of Bob's cards that Alice can cover.
Please pay attention that each card can be used only once and the cards cannot be rotated.
 

Input
The first line of the input is a number T (T <= 40) which means the number of test cases. 
For each case, the first line is a number N which means the number of cards that Alice and Bob have respectively. Each of the following N (N <= 100,000) lines contains two integers h (h <= 1,000,000,000) and w (w <= 1,000,000,000) which means the height and width of Alice's card, then the following N lines means that of Bob's.
 

Output
For each test case, output an answer using one line which contains just one number.
 

Sample Input
2
2
1 2
3 4
2 3
4 5
3
2 3
5 7
6 8
4 1
2 5
3 4 
 

Sample Output
1
2
 

Source
2012 ACM/ICPC Asia Regional Changchun Online
 

```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月07日 星期一 13时19分39秒
File Name     :B.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=100100;

int n;
struct RECT
{
	int w,h;
	bool operator<(const RECT& rect) const
	{
		if(w!=rect.w) return w<rect.w;
		return h<rect.h;
	}
}rb[maxn],ra[maxn];

multiset<int> mis;

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    int T_T;
    scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		for(int i=0;i<n;i++)
			scanf("%d%d",&ra[i].w,&ra[i].h);
		for(int i=0;i<n;i++)
			scanf("%d%d",&rb[i].w,&rb[i].h);
		sort(ra,ra+n); sort(rb,rb+n);
		int j=0,ans=0;
		mis.clear();
		for(int i=0;i<n;i++)
		{
			while(j<n)
			{
				if(rb[j].w<=ra[i].w)
                {
                    mis.insert(rb[j].h); j++;
                }
                else break;
			}
			/*
			for(auto x : mis)
                cout<<x<<",";
            cout<<endl;
            */

            //cout<<"find: "<<ra[i].h<<endl;
            multiset<int>::iterator item=mis.upper_bound(ra[i].h);
            //cout<<"item: "<<*item<<endl;
            if(item==mis.begin()) continue;
            else
            {
                item--;
                //cout<<"hrere"<<endl;
                ans++;
                int x=*item;
                mis.erase(mis.find(x));
            }
		}
		printf("%d\n",ans);
	}

    return 0;
}
```

