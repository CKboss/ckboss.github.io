title: HDOJ 5481 Desiderium 期望+线段树
date: 2015-10-01 12:07:08
tags:
- 线段树

categories:
- acm_数据结构

---

##### 题意:
给n条线段,求随意选取几根线段的线段并的期望.

##### 解:
其实就是求所有子集的长度并的和,离散化后用线段树求每一小段都属于那些线段.
设总共有n条线段,某一小段出现在m条线段中,则这一小段所贡献的长度为: $2^n-2^{m-n}$


### [Desiderium](http://acm.hdu.edu.cn/showproblem.php?pid=5481)

Time Limit: 4000/2000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 465    Accepted Submission(s): 177


##### Problem Description
There is a set of intervals, the size of this set is n.

If we select a subset of this set with equal probability, how many the expected length of intervals' union of this subset is?

We assume that the length of empty set's union is 0, and we want the answer multiply 2n modulo 109+7.
 

##### Input
The first line of the input is a integer T, meaning that there are T test cases.

Every test cases begin with a integer n ,which is size of set.

Then n lines follow, each contain two integers l,r describing a interval of [l,r].

1≤n≤100,000.

−1,000,000,000≤l≤r≤1,000,000,000.


##### Output
For every test case output the answer multiply 2n modulo 109+7.

```cpp
Sample Input
2
1
0 1
2
0 2
1 3


Sample Output
1
7
```

##### Hint
For the second sample, the excepted length is $\frac{0+2+2+3}{4}=\frac{7}{4}$.



##### Source
BestCoder Round #57 (div.2)

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月01日 星期四 10时16分20秒
File Name     :HDOJ5481.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;

const int maxn=100100;
const LL mod=1e9+7LL;

int n,hn;
int has[maxn*2];

struct Duan
{
	int l,r;
}duan[maxn];

/********* seg tree *****************/

#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1

LL tree[maxn<<5];
LL add[maxn<<5];

void push_up(int rt)
{
	tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void push_down(int l,int r,int rt)
{
	if(add[rt])
	{
		int m=(l+r)/2;

		tree[rt<<1]+=(m-l+1)*add[rt];
		tree[rt<<1|1]+=(r-m)*add[rt];

		add[rt<<1]+=add[rt]; add[rt<<1|1]+=add[rt];

		add[rt]=0;
	}
}

void build(int l,int r,int rt)
{
	tree[rt]=add[rt]=0;
	if(l==r) return ; 
	int m=(l+r)/2;
	build(lson); build(rson);
}

void update(int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R)
	{
		tree[rt]+=(r-l+1);
		add[rt]+=1;
		return ;
	}

	push_down(l,r,rt);

	int m=(l+r)/2;

	if(L<=m) update(L,R,lson);
	if(R>m) update(L,R,rson);

	push_up(rt);
}

LL query(int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R) return tree[rt];

	push_down(l,r,rt);

	int m=(l+r)/2;
	LL ret=0;

	if(L<=m) ret+=query(L,R,lson);
	if(R>m) ret+=query(L,R,rson);

	return ret;
}

LL QP[maxn*2];

LL QuickPow(LL x,int n)
{
	LL e=1LL;
	LL& p=QP[n];
	if(p!=-1) return p;
	while(n)
	{
		if(n&1) e=(e*x)%mod;
		x=(x*x)%mod;
		n/=2;
	}
	return p=e%mod;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	memset(QP,-1,sizeof(QP));
	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		hn=0;
		for(int i=0;i<n;i++)
		{
			scanf("%d%d",&duan[i].l,&duan[i].r);
			has[hn++]=duan[i].l; has[hn++]=duan[i].r;
		}
		sort(has,has+hn);


		hn=unique(has,has+hn)-has;
		for(int i=0;i<n;i++)
		{
			duan[i].l=lower_bound(has,has+hn,duan[i].l)-has+1;
			duan[i].r=lower_bound(has,has+hn,duan[i].r)-has+1;
		}

		build(1,hn,1);

		for(int i=0;i<n;i++)
		{
			update(duan[i].l,duan[i].r-1,1,hn,1);
		}
		LL ans=0;
		for(int i=0;i+1<hn;i++)
		{
			LL dur=has[i+1]-has[i];
			LL nb=query(i+1,i+1,1,hn,1);
			ans+=(dur*(QuickPow(2,n)-QuickPow(2,n-nb)+mod)%mod)%mod;
		}

		printf("%lld\n",ans%mod);
	}
    
    return 0;
}
````


