title: HDOJ 4406 GPA 最大费用最大流
date: 2015-09-07 17:11:54
tags: 
- acm
- acm_图论 
- 费用流
categories: 
- acm_图论
---
### 最大费用最大流

根据GPA的涨幅可以看出,分数越高对于的gpa涨幅就越小.
为了先保证及格,将边连到

* 建图:

1. 源点S向每个课程连一些边,
    如果该课程的分数小于60就连(60-s)条容量1费用inf的边
    然后连max(s,60)~100条容量1费用为deta_p*w[i]的边
2. 课程向对应的天连(容量K,费用0)的边
3. 天向汇点连(容量K,费用0)的边

**跑最大费用最大流**,然后检查S往每门课连的边,统计一下每门课的连边数量.

最后判断有没有不及格的课并计算GPA


[传送门HDOJ4406](http://acm.hdu.edu.cn/showproblem.php?pid=4406)


### GPA

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 890    Accepted Submission(s): 323


Problem Description

GPA(Grade-Point Average) is one way to measure students’ academic performance in PKU. Each course has an integer credit, ranges from 1 to 99. For each course, you will get a score at the end of the semester, which is an integer ranges from 0 to 100. Then you can calculate the Grade-Point of this course with the following formula. (Your score is x and your Grade-Point is p, using real arithmetic)

![](http://acm.hdu.edu.cn/data/images/C417-1007-1.jpg)

Then you can get the GPA with the following formula (the Grade-Point of course i is pi, and the credit of course i is wi).

![](http://acm.hdu.edu.cn/data/images/C417-1007-2.jpg)

Now it is not far from the final exam, if you do not review, you can only get a basic score in each course.

You have n days to review. There are K classes in each day. For each class, only one course can be reviewed. After the review, your score in this course will exactly increase by 1. You can get more increment by spending more classes in this course. But the score may not exceed 100.

For some reasons, not any course can be reviewed in any class. Each day you can only review some of the courses.

Now you want your GPA to be as high as possible, and at the same time, you do not want to fail in any course. Please calculate the highest GPA you can get. 
 

Input

The input consists of several test cases. Each test case begins with 3 integers N (0<=N<=40), K(0<K<=20), M (0<M<=20), representing the number of days, the number of classes in each day and the number of courses. Next line contains M integers representing credits of each course and M integers representing basic scores of each course (0<=score<=100). Next N lines contain an N*M matrix, the jth element in ith row means whether you can review course j in ith day, 1 means you can review course j in ith day, 0 means you cannot. The Input ends with 0 0 0.
 

Output

For each test case, output the highest possible GPA, round to 6 digits after decimal point. If you have to fail a course, output 0.000000 instead.
 

```
Sample Input
2 10 3
1 1 2
50 60 90
1 1 0
1 0 1
2 20 4
1 1 1 1
50 50 50 40
1 1 1 0
0 0 0 1
0 0 0

Sample Output
2.757813
0.000000
 
```
Source
2012 ACM/ICPC Asia Regional Jinhua Online
 
 
 
```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月06日 星期日 21时05分03秒
File Name     :HDOJ4406.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=500;
const int maxm=100100;
const int INF=0x3f3f3f3f;
const double inf=1e7;
const double eps=1e-8;

struct Edge
{
	int to,next,cap,flow;
	double cost;
}edge[maxm];

int Adj[maxn],Size;
int S,T,N;

void init()
{
	memset(Adj,-1,sizeof(Adj)); Size=0;
}

void addedge(int u,int v,int cap,double cost)
{
	edge[Size].to=v;
	edge[Size].next=Adj[u];
	edge[Size].cost=cost;
	edge[Size].cap=cap;
	edge[Size].flow=0;
	Adj[u]=Size++;
}

int Add_Edge(int u,int v,int cap,double cost)
{
	int ret=Size;
	addedge(u,v,cap,cost);
	addedge(v,u,0,-cost);
	return ret;
}

double dist[maxn];
int vis[maxn],pre[maxn];

bool spfa(int s,int t)
{
	queue<int> q;
	for(int i=0;i<N;i++)
	{
		dist[i]=-inf; vis[i]=false; pre[i]=-1;
	}
	dist[s]=0; vis[s]=true; q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=false;
		for(int i=Adj[u];~i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(edge[i].cap>edge[i].flow
					&&dist[v]<dist[u]+edge[i].cost-eps)
			{
				dist[v]=dist[u]+edge[i].cost;
				pre[v]=i;
				if(!vis[v])
				{
					vis[v]=true;
					q.push(v);
				}
			}
		}
	}
	if(pre[t]==-1) return false;
	return true;
}

int MinCostMaxFlow(int s,int t,double& cost)
{
	double flow=0;
	cost=0;
	while(spfa(s,t))
	{
		int Min=INF;
		for(int i=pre[t];~i;i=pre[edge[i^1].to])
		{
			if(Min>edge[i].cap-edge[i].flow)
			{
				Min=edge[i].cap-edge[i].flow;
			}
		}
		//if(dist[t]<-eps) break;
		for(int i=pre[t];~i;i=pre[edge[i^1].to])
		{
			edge[i].flow+=Min;
			edge[i^1].flow-=Min;
			cost+=edge[i].cost*Min;
		}
		flow+=Min;
	}
	return flow;
}

int n,K,m;
int w[maxn],base[maxn];
int add[maxn];
int G[maxn][maxn];
double ps[maxn];
int nextnode;

double Cost(int x,int w)
{
	return (4.0-3.0*(100.0-x)*(100.0-x)/1600.0)*w;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);


	while(scanf("%d%d%d",&n,&K,&m)!=EOF)
	{
		if(n==0&&K==0&&m==0) break;

		double sw=0;
		for(int i=1;i<=m;i++) 
		{
			scanf("%d",&w[i]); sw+=(double)w[i];
		}
		for(int i=1;i<=m;i++) scanf("%d",&base[i]);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				scanf("%d",&G[i][j]);

		init();
		S=0; T=m+n+1; N=T+1;

		for(int i=1;i<=m;i++)
		{
			for(int j=base[i];j<60;j++) 
			{
				Add_Edge(S,i,1,1e10);
			}
			for(int j=max(base[i],60);j<100;j++)
			{
				double ww=Cost(j+1,w[i])-Cost(j,w[i]);
				Add_Edge(S,i,1,ww);
			}
		}

		for(int i=1;i<=n;i++)
		{
			Add_Edge(i+m,T,K,0);
			for(int j=1;j<=m;j++)
			{
				if(G[i][j]==1)
				{
					Add_Edge(j,m+i,K,0);
				}
			}
		}

		int flow; double cost;
		flow=MinCostMaxFlow(S,T,cost);

		memset(add,0,sizeof(add));
		for(int i=Adj[S];~i;i=edge[i].next)
		{
			if(edge[i].flow==1)
			{
				add[edge[i].to]++;
			}
		}

		double sum=0;
		bool flag=true;
		for(int i=1;i<=m&&flag;i++)
		{
			if(base[i]+add[i]<60) flag=false;
			sum+=Cost(base[i]+add[i],w[i]);
		}
		if(flag==false)
		{
			puts("0.000000");
		}
		else
		{
			printf("%.6lf\n",sum/sw+eps);
		}
	}

    return 0;
}

```
