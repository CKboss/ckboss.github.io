title: HDOJ 2475 Box LCT(分离,合并,寻根)

date: 2015-11-01 21:37:46

tags:
- LCT

categories:
- acm_数据结构

---

LCT裸题....
08年就出现的LCT,而我到现在用的都不熟练....

# [Box](http://acm.hdu.edu.cn/showproblem.php?pid=2475)

Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 2684    Accepted Submission(s): 783


##### Problem Description
There are N boxes on the ground, which are labeled by numbers from 1 to N. The boxes are magical, the size of each one can be enlarged or reduced arbitrarily.
Jack can perform the “MOVE x y” operation to the boxes: take out box x; if y = 0, put it on the ground; Otherwise, put it inside box y. All the boxes inside box x remain the same. It is possible that an operation is illegal, that is, if box y is contained (directly or indirectly) by box x, or if y is equal to x.
In the following picture, box 2 and 4 are directly inside box 6, box 3 is directly inside box 4, box 5 is directly inside box 1, box 1 and 6 are on the ground.

![](http://acm.hdu.edu.cn/data/images/C165-1002-1.jpg)

The picture below shows the state after Jack performs “MOVE 4 1”:

![](http://acm.hdu.edu.cn/data/images/C165-1002-2.jpg)

Then he performs “MOVE 3 0”, the state becomes:

![](http://acm.hdu.edu.cn/data/images/C165-1002-3.jpg)

During a sequence of MOVE operations, Jack wants to know the root box of a specified box. The root box of box x is defined as the most outside box which contains box x. In the last picture, the root box of box 5 is box 1, and box 3’s root box is itself.


##### Input
Input contains several test cases.
For each test case, the first line has an integer N (1 <= N <= 50000), representing the number of boxes.
Next line has N integers: a1, a2, a3, ... , aN (0 <= ai <= N), describing the initial state of the boxes. If ai is 0, box i is on the ground, it is not contained by any box; Otherwise, box i is directly inside box ai. It is guaranteed that the input state is always correct (No loop exists).
Next line has an integer M (1 <= M <= 100000), representing the number of MOVE operations and queries.
On the next M lines, each line contains a MOVE operation or a query:
1.  MOVE x y, 1 <= x <= N, 0 <= y <= N, which is described above. If an operation is illegal, just ignore it.
2.  QUERY x, 1 <= x <= N, output the root box of box x.
 

##### Output
For each query, output the result on a single line. Use a blank line to separate each test case.
 

```
Sample Input
2
0 1
5
QUERY 1
QUERY 2
MOVE 2 0
MOVE 1 2
QUERY 1
6
0 6 4 6 1 0
4
MOVE 4 1
QUERY 3
MOVE 1 4
QUERY 1


Sample Output
1
1
2

1
1
```

Source
2008 Asia Regional Chengdu

<!--more-->

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long int LL;

const int maxn=100100;

int ch[maxn][2],pre[maxn];
bool rev[maxn],rt[maxn];

void Rotate(int x)
{
  int y=pre[x],kind=ch[y][1]==x;
  ch[y][kind]=ch[x][!kind];
  pre[ch[y][kind]]=y;
  pre[x]=pre[y];
  pre[y]=x;
  ch[x][!kind]=y;
  if(rt[y]) rt[y]=false,rt[x]=true;
  else ch[pre[x]][ch[pre[x]][1]==y]=x;
}

void Splay(int r)
{
  while(!rt[r])
    {
      int f=pre[r],ff=pre[f];
      if(rt[f]) Rotate(r);
      else if((ch[ff][1]==f)==(ch[f][1]==r)) Rotate(f),Rotate(r);
      else Rotate(r),Rotate(r);
    }
}

int Access(int x)
{
  int y=0;
  for(;x;x=pre[y=x])
    {
      Splay(x);
      rt[ch[x][1]]=true; rt[ch[x][1]=y]=false;
    }
  return y;
}

void mroot(int r)
{
  Access(r);
  Splay(r);
}

void link(int u,int v)
{
  mroot(u);
  pre[u]=v;
}

void cut(int u,int v)
{
  mroot(u);
  Splay(v);
  pre[ch[v][0]]=pre[v];
  pre[v]=0;
  rt[ch[v][0]]=true;
  ch[v][0]=0;
}

void cut(int v)
{
    mroot(v);
    pre[ch[v][0]]=0;
    rt[ch[v][0]]=true;
    ch[v][0]=0;
}

void join(int v,int u)
{
    if(!u) cut(v);
    else
    {
        mroot(u);
        int tv=v;
        while(!rt[tv]) tv=pre[tv];
        if(tv!=u)
        {
            cut(v);
            pre[v]=u;
        }
    }
}

int n,q;

void init()
{
  for(int i=0;i<=n+10;i++)
    {
      ch[i][0]=ch[i][1]=0;
      pre[i]=0; rt[i]=true; rev[i]=false;
    }
}

void showit(int x)
{
    if(x)
    {
        showit(ch[x][0]);
        printf("结点: %2d 左儿子: %2d 右儿子: %2d 父结点: %2d\n",
               x,ch[x][0],ch[x][1],pre[x]);
        showit(ch[x][1]);
    }
}

void debug()
{
  for(int i=0;i<=n;i++)
    {
      if(rt[i])
        {
          cout<<"ROOT: "<<i<<endl;
          showit(i);
          cout<<"..........\n";
        }
    }
}

int find_root(int r)
{
    mroot(r);
    while(ch[r][0]) r=ch[r][0];
    return r;
}

void init_lct(int n)
{
    for(int i=0;i<n+10;i++)
    {
        pre[i]=0; ch[i][0]=ch[i][1]=0; rt[i]=true;
    }
}

char cmd[20];
int x,y;

int main()
{
    bool first=true;
    while(scanf("%d",&n)!=EOF)
    {
        if(first==true) first=false;
        else putchar(10);

        init_lct(n);
        for(int i=1;i<=n;i++) scanf("%d",pre+i);
        scanf("%d",&q);
        while(q--)
        {
            scanf("%s",cmd);
            if(cmd[0]=='Q')
            {
                /// find root;
                scanf("%d",&x);
                printf("%d\n",find_root(x));
            }
            else if(cmd[0]=='M')
            {
                /// move x to y
                scanf("%d%d",&x,&y);
                join(x,y);
            }
        }
    }
    return 0;
}
```