title: HDOJ 4288 Coder 线段树
date: 2015-09-17 20:12:12
tags:
- 线段树
categories:
- acm_数据结构
---

**线段树**:
* 先离散化,然后用一个$10^5$的线段树维护

* 每个节点用一个数组维护一下%5的值,同时维护一下每个节点的中已经插入的点的数量.

每个节点可以这样维护:
```cpp
int pc = sz[x<<1];
for(int i=0;i<5;i++)
{
	tree[x][i]=tree[x<<1][i]+tree[x<<1|1][(i-pc+5)%5];
}
```


### Coder

Time Limit: 20000/10000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4643    Accepted Submission(s): 1772


##### Problem Description
　　In mathematics and computer science, an algorithm describes a set of procedures or instructions that define a procedure. The term has become increasing popular since the advent of cheap and reliable computers. Many companies now employ a single coder to write an algorithm that will replace many other employees. An added benefit to the employer is that the coder will also become redundant once their work is done. 1
　　You are now the signle coder, and have been assigned a new task writing code, since your boss would like to replace many other employees (and you when you become redundant once your task is complete).
Your code should be able to complete a task to replace these employees who do nothing all day but eating: make the digest sum.
　　By saying “digest sum” we study some properties of data. For the sake of simplicity, our data is a set of integers. Your code should give response to following operations:
　　1. add x – add the element x to the set;
　　2. del x – remove the element x from the set;
　　3. sum – find the digest sum of the set. The digest sum should be understood by

![](http://acm.hdu.edu.cn/data/images/C415-1001-1.jpg)

　　where the set S is written as {a1, a2, ... , ak} satisfying a1 < a2 < a3 < ... < ak
  
　　Can you complete this task (and be then fired)?

1 See http://uncyclopedia.wikia.com/wiki/Algorithm
 

##### Input
　　There’re several test cases.
　　In each test case, the first line contains one integer N ( 1 <= N <= 105 ), the number of operations to process.
　　Then following is n lines, each one containing one of three operations: “add x” or “del x” or “sum”.
　　You may assume that 1 <= x <= 109.
　　Please see the sample for detailed format.
　　For any “add x” it is guaranteed that x is not currently in the set just before this operation.
　　For any “del x” it is guaranteed that x must currently be in the set just before this operation.
　　Please process until EOF (End Of File).
 

##### Output
　　For each operation “sum” please print one line containing exactly one integer denoting the digest sum of the current set. Print 0 if the set is empty.

<!-- more -->

```
Sample Input
9
add 1
add 2
add 3
add 4
add 5
sum
add 6
del 3
sum
6
add 1
add 3
add 5
add 7
add 9
sum
 

Sample Output
3
4
5
```

Hint
C\++ maybe run faster than G\++ in this problem.
 
 

Source
2012 ACM/ICPC Asia Regional Chengdu Online
 
```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月17日 星期四 19时25分47秒
File Name     :HDOJ4288.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;
const int maxn=100100;

int n,hn;
LL hs[maxn];

struct Do
{
	int kind;
	LL val;
}cao[maxn];

char cmd[20];

/********************TREE***************************/

#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1

/// % value
LL tree[maxn<<2][5];
// size
int sz[maxn<<2];

void push_up(int x)
{
	sz[x]=sz[x<<1]+sz[x<<1|1];
	int pc=sz[x<<1]%5;
	for(int i=0;i<5;i++)
	{
		tree[x][i]=tree[x<<1][i]+tree[x<<1|1][(i-pc+5)%5];
	}
}

void build(int l,int r,int rt)
{
	if(l==r)
	{
		sz[rt]=0;
		for(int i=0;i<5;i++) 
			tree[rt][i]=0;
		return ;
	}
	int m=(l+r)/2;
	build(lson); build(rson);
	push_up(rt);
}

void update(int p,LL V,int l,int r,int rt)
{
	if(l==r)
	{
		tree[rt][1]+=V;
		if(tree[rt][1]) sz[rt]=1;
		else sz[rt]=0;
		return ;
	}

	int m=(l+r)/2;
	if(p<=m) update(p,V,lson);
	if(p>m) update(p,V,rson);
	push_up(rt);
}

void show(int l,int r,int rt)
{
	printf("rt: %d  %d <-----> %d \n",rt,l,r);
	for(int i=0;i<5;i++)
		cout<<tree[rt][i]<<",";
	cout<<endl;

	if(l==r) return ;

	int m=(l+r)/2;
	show(lson); show(rson);
}


int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d",&n)!=EOF)
	{
		hn=0;
		for(int i=0,x;i<n;i++)
		{
			scanf("%s",cmd);
			if(cmd[0]=='a')
			{
				scanf("%d",&x);
				cao[i]=(Do){1,x};
				hs[hn++]=x;
			}
			else if(cmd[0]=='d')
			{
				scanf("%d",&x);
				cao[i]=(Do){2,x};
				hs[hn++]=x;
			}
			else 
			{
				cao[i]=(Do){3,-1};
			}
		}
		sort(hs,hs+hn);
		hn=unique(hs,hs+hn)-hs;

		build(1,hn,1);

		for(int i=0;i<n;i++)
		{
			if(cao[i].kind==1||cao[i].kind==2)
			{
				LL v=cao[i].val;
				int id=lower_bound(hs,hs+hn,v)-hs+1;
				if(cao[i].kind==2) v=-v;
				update(id,v,1,hn,1);
			}
			else
			{
				printf("%lld\n",tree[1][3]);
			}
		}

	}

    return 0;
}
```
