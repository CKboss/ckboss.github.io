title: HDOJ 4275 Color the Tree 树hash+树DP+组合数
date: 2015-09-11 11:41:55
tags:
- acm
- dp
- 组合数
categories:
- acm_dp
---

### 树hash+树DP+组合数学
比较综合的一题

* 如何进行树hash:

采用的hash表达式如下 
对于结点u, u有儿子结点v1, v2, ..., vk 
其中儿子结点的Hash值已经处理出来时H[1~k] 
那么首先对于Hash值进行排序, (相同的子树的hash值一定是一样的, 于是同构的子树一定会被排在一起 

Hash(v) = ((...(((((a*p ^ H[1]) mod q) *p ^ H[2]) % q) * p ^ .... H[k - 1]) mod q)*p ^ H[k]) * b % q

其中a, p, q, b为参数自选, ^表示异或, 这里没考虑优先级问题, 表达式从左向右计算 


* 树的中心

找到树的中心,然后再进行树的hash就可以判断两棵树是否一样了.
什么是树的中心呢?

**直径上的中点,如果直径为奇数就是最中间的点,为偶数可以添加一个虚拟点**

* 有v种物品,要求取k个可以重复取有多少种取法:

$$\binom{v+k-1}{v-1}$$

所以这一题可以先求树的中心,然后从中心开始求树的hash,最后用树形dp来统计答案就可以了.

时间卡的不紧,求树hash,和树形dp的部分分开写了...

<!-- more -->

***

## [Color the Tree](http://acm.hdu.edu.cn/showproblem.php?pid=4275)

Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 327680/327680 K (Java/Others)
Total Submission(s): 548    Accepted Submission(s): 195


#### Problem Description
Now you have a tree with N vertices, and M pens with different color. You want to paint the vertices by your pens, and wondered that how many kinds of different colored trees could be resulted after painting.
Pay attention that two isomorphic trees having same color in corresponding vertices could be considered as two same colored trees.
 

#### Input
There are multiple test cases.
The first line contains two integers N and M. (1 <= N<=50,000,1<= M <= 100,000)
The next N - 1 lines each line contains two integer Ai and Bi indicating there is one tree edge between Ai and Bi. (1 <= Ai, Bi <= N)
 

#### Output
For each test case, output a number module 1000000007 (1e9 + 7) indicating the answer.
 
```shell
Sample Input
1 3

2 3
1 2

5 2
1 2
1 3
3 4
3 5
 

Sample Output
3
6
24

```

Source

[2012 ACM/ICPC Asia Regional Changchun Online](http://acm.hdu.edu.cn/search.php?field=problem&key=2012+ACM%2FICPC+Asia+Regional+Changchun+Online&source=1&searchmode=source)
 


```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long int LL;

const int maxn=50100;
const LL mod=1e9+7LL;

int n,m;

struct Edge
{
    int to,next;
}edge[maxn*2];

int Adj[maxn],Size;

void init()
{
    memset(Adj,-1,sizeof(Adj)); Size=0;
}

void Add_Edge(int u,int v)
{
    edge[Size].to=v;
    edge[Size].next=Adj[u];
    Adj[u]=Size++;
}

int dist[maxn];
int pre[maxn];

void dfs(int u,int fa)
{
	pre[u]=fa;
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;
		dist[v]=dist[u]+1;
		dfs(v,u);
	}
}

int s,t,vroot;
vector<int> vi;

void findRoad(int t)
{
	vi.clear();
	while(t!=s)
	{
		vi.push_back(t);
		t=pre[t];
	}
	vi.push_back(s);
}

void cutUV(int u,int v)
{
	int last=Adj[u];
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		if(edge[i].to==v)
		{
			if(edge[last].next!=edge[i].next) edge[last].next=edge[i].next;
			else Adj[u]=edge[i].next;
		}
		last=i;
	}
}

LL Hash[maxn];

const LL h_A=233LL,h_P=23333LL,h_B=50009LL,h_Q=1e9+1027LL;

void GetHash(int u,int fa)
{
	vector<LL> hs;
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;
		GetHash(v,u);
		hs.push_back(Hash[v]);
	}
	int sz=hs.size();
	if(sz==0)
	{
		Hash[u]=h_A*h_P;
		Hash[u]*=h_B;
		Hash[u]%=h_Q;
		return ;
	}
	sort(hs.begin(),hs.end());
	LL HS=h_A;
	for(int i=0;i<sz-1;i++)
	{
		HS=HS*h_P;
		HS=HS^hs[i];
		HS%=h_Q;
	}
	
	HS=HS*h_P;
	HS=HS^hs[sz-1];
	HS=HS*h_B;
	HS=HS%h_Q;

	Hash[u]=HS;
}

/********* 计算组合数取模 *****************/
LL fac[maxn];

void PRE()
{
	fac[0]=fac[1]=1LL;
	for(LL i=2;i<maxn;i++) fac[i]=(fac[i-1]*i)%mod;
}

LL quickpow(LL a,LL n)
{
	LL e=1LL;
	while(n)
	{
		if(n&1) e=(e*a)%mod;
		a=(a*a)%mod;
		n/=2LL;
	}
	return e%mod;
}

LL C(LL x,LL y)
{
	y=min(y,x-y);
	LL ret=1LL;
	for(LL i=1;i+x-y<=x;i++)
		ret=ret*(x-y+i)%mod;
	ret=ret*quickpow(fac[y],mod-2LL)%mod;
	return ret;
}


/********* 树形DP统计答案 *****************/

/// u号节点有多少种涂色方法
LL dp[maxn];

bool cmp(int a,int b) { return Hash[a]<Hash[b]; }

void ddfs(int u,int fa)
{
	vector<LL> hs;
	vector<int> hid;
	for(int i=Adj[u];~i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==fa) continue;
		ddfs(v,u);
		hs.push_back(Hash[v]);
		hid.push_back(v);
	}
	int sz=hs.size();

	dp[u]=m; 
	if(sz==0) return ;

	sort(hs.begin(),hs.end());
	sort(hid.begin(),hid.end(),cmp);

	LL last=hs[0];
	int numbs=1;
	for(int i=1;i<sz;i++)
	{
		if(hs[i]!=last)
		{
			int v=hid[i-1];
			dp[u]=(dp[u]*C(numbs+dp[v]-1,dp[v]-1))%mod;

			last=hs[i]; numbs=1;
		}
		else numbs++;
	}
	int v=hid[sz-1];
	dp[u]=(dp[u]*C(numbs+dp[v]-1,dp[v]-1))%mod;
}

int main()
{
	PRE();
    while(scanf("%d%d",&n,&m)!=EOF)
    {
        init();
        for(int i=0,u,v;i<n-1;i++)
        {
            scanf("%d%d",&u,&v);
            Add_Edge(u,v); Add_Edge(v,u);
        }

		for(int i=1;i<=n;i++) dist[i]=0;

		pre[1]=1; dfs(1,1);
		s=1;
		for(int i=2;i<=n;i++) if(dist[i]>dist[s]) s=i;
		for(int i=1;i<=n;i++) dist[i]=0;
		pre[s]=s; dfs(s,s);
		t=1;
		for(int i=2;i<=n;i++) if(dist[i]>dist[t]) t=i;

		findRoad(t);

		int sz=vi.size();
		if(sz%2==1) vroot=vi[sz/2];
		else
		{
			vroot=n+1; n++;
			int u=vi[sz/2-1],v=vi[sz/2];
			Add_Edge(vroot,u); Add_Edge(vroot,v);
			cutUV(u,v); cutUV(v,u);
		}

		GetHash(vroot,vroot);
		ddfs(vroot,vroot);

		if(sz%2==0)
			dp[vroot]=dp[vroot]*quickpow(m,mod-2LL)%mod;

		printf("%lld\n",dp[vroot]);
    }
    return 0;
}

```
