title: HDOJ 4267 A Simple Problem with Integers 树状数组
date: 2015-09-08 19:11:54
tags:
- acm_数据结构
- 树状数组
categories:
- acm_数据结构
---

#### 建10*10个树状数组,$tree[x][y]$表示从x开始等差为y的树状数组.对于每个询问a,统计与a相关的的数组数组的和.

---

### A Simple Problem with Integers

Time Limit: 5000/1500 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)
Total Submission(s): 4566    Accepted Submission(s): 1406


Problem Description
Let A1, A2, ... , AN be N elements. You need to deal with two kinds of operations. One type of operation is to add a given number to a few numbers in a given interval. The other is to query the value of some element.
 

Input
There are a lot of test cases. 
The first line contains an integer N. (1 <= N <= 50000)
The second line contains N numbers which are the initial values of A1, A2, ... , AN. (-10,000,000 <= the initial value of Ai <= 10,000,000)
The third line contains an integer Q. (1 <= Q <= 50000)
Each of the following Q lines represents an operation.
"1 a b k c" means adding c to each of Ai which satisfies a <= i <= b and (i - a) % k == 0. (1 <= a <= b <= N, 1 <= k <= 10, -1,000 <= c <= 1,000)
"2 a" means querying the value of Aa. (1 <= a <= N)
 

Output
For each test case, output several lines to answer all query operations.
 
```
Sample Input
4 
1 1 1 1
14
2 1
2 2
2 3
2 4
1 2 3 1 2
2 1 
2 2
2 3
2 4
1 1 4 2 1
2 1
2 2
2 3
2 4
 

Sample Output
1
1
1
1
1
3
3
1
2
3
4
1
```

Source
2012 ACM/ICPC Asia Regional Changchun Online
 
```c++
/* ***********************************************
Author        :CKboss
Created Time  :2015年09月07日 星期一 22时43分29秒
File Name     :HDOJ4267.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=50500;

inline int lowbit(int x) { return x&(-x); }

int color[12][12][maxn];
int tree[12][12][maxn];
int C=0;

void add(int x,int y,int p,int v)
{
	for(int i=p;i<maxn;i+=lowbit(i))
	{
		if(color[x][y][i]!=C)
		{
			tree[x][y][i]=0;
			color[x][y][i]=C;
		}
		tree[x][y][i]+=v;
	}
}

int sum(int x,int y,int p)
{
	int ret=0;
	for(int i=p;i>0;i-=lowbit(i))
	{
		if(color[x][y][i]==C)
			ret+=tree[x][y][i];
	}
	return ret;
}

int calu(int u)
{
	int ret=0;
	for(int x=1;x<=10;x++)
	{
		for(int y=1;y<=10;y++)
		{ 
			if((u-x)%y==0)
			{
				ret+=sum(x,y,u);
			}
		}
	}
	return ret;
}

int n,m,A[maxn];
int kind,a,b,k,c;

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	while(scanf("%d",&n)!=EOF)
	{
		for(int i=1;i<=n;i++) scanf("%d",A+i);
		C++;
		scanf("%d",&m);
		while(m--)
		{
			scanf("%d",&kind);
			if(kind==1)
			{
				scanf("%d%d%d%d",&a,&b,&k,&c);
				int x=(a%k); if(x==0) x=k;
				add(x,k,a,c);
				add(x,k,b+1,-c);
			}
			else if(kind==2)
			{
				scanf("%d",&a);
				printf("%d\n",calu(a)+A[a]);
			}
		}
	}
    
    return 0;
}

```


