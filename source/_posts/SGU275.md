title: SGU 275 To xor or not to xor 高斯消元
date: 2015-11-03 20:02:51
tags:
- 高斯消元

categories:
- acm_数学

---

给n个数,让你从中间选一些数使异或值最大.


**高斯消元**,矩阵a[i][j]表示第j个数的第i位是0还是1.

首先求系数矩阵。由每个数的范围可以确定每个数转化成二进制以后最多有63位，那么我们构造一个63*100的矩阵，a[i][j]表示第j个数的第i个二进制位，因为我们想要结构最大，最后一列置为1，然后用高斯消元判断每一行即想要结果的每一位能不能取得1。
从高位向低位，判断每一行是否有可控制变元(是否有1)，如果有那么这一行可以取得1，同时从该行往下依次异或掉该列不为0的行，即异或掉该变元。如果没有可控制的变元，但是最后一列是0，该行结构也是1，若最后一列不为0说明该行结果为0。从高位向低位，每次确定了一位后，就更新ans的值，最后取得一个最大值。



# [275. To xor or not to xor](http://acm.sgu.ru/problem.php?contest=0&problem=275)

time limit per test: 0.25 sec.
memory limit per test: 65536 KB
input: standard
output: standard



The sequence of non-negative integers A1, A2, ..., AN is given. You are to find some subsequence Ai1, Ai2, ..., Aik (1 <= i1 < i2 < ... < ik <= N) such, that Ai1 XOR Ai2 XOR ... XOR Aik has a maximum value.

##### Input
The first line of the input file contains the integer number N (1 <= N <= 100). The second line contains the sequence A1, A2, ..., AN (0 <= Ai <= 10^18). 

##### Output
Write to the output file a single integer number -- the maximum possible value of Ai1 XOR Ai2 XOR ... XOR Aik. 
```
Sample test(s)

Input
3 
11 9 5 

Output
14
```

[submit]
[forum]
Author:	Michael R. Mirzayanov
Resource:	ACM ICPC 2004-2005, NEERC, Southern Subregional Contest
Date:	Saratov, October 7, 2004

<!--more-->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年11月03日 星期二 11时28分53秒
File Name     :SGU275.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long int LL;
const int maxn=111;

int n;
int a[63][maxn];
bool vis[maxn];

LL gauss()
{
    LL ret=0;
    for(int i=62;i>=0;i--)
    {
        int x=-1;
        for(int j=0;j<n;j++)
        {
            if(a[i][j]==1&&!vis[j])
            {
                x=j; break;
            }
        }
        if(x==-1&&a[i][n]==0)
        {
            ret=ret|(1LL<<i);
        }
        else if(x!=-1)
        {
            vis[x]=true;
            ret=ret|(1LL<<i);

            for(int j=i-1;j>=0;j--)
            {
                if(a[j][x]==0) continue;
                for(int k=0;k<=n;k++)
                {
                    a[j][k]^=a[i][k];
                }
            }
        }
    }
    return ret;
}

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

    while(scanf("%d",&n)!=EOF)
    {
        for(int i=0;i<n;i++)
        {
            LL x;
            scanf("%lld",&x);
            for(int j=0;j<63;j++)
            {
                a[j][i]=x%2LL;
                x/=2LL;
            }
        }

        for(int i=0;i<63;i++) a[i][n]=1;
        printf("%lld\n",gauss());
    }
    
    return 0;
}
```