title: HDOJ 5497 Inversion 线段树
date: 2015-10-12 10:49:27
tags:
- 线段树

categories:
- acm_数据结构

---

题意:
一段长度为n的数组,可以去掉连续的m个数字,问最小的逆序数是多少

解:
用维护一个m大小的窗口,移动时用线段树维护inv,具体细节见代码

### [Inversion](http://acm.hdu.edu.cn/showproblem.php?pid=5497)

Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 731    Accepted Submission(s): 200


##### Problem Description
You have a sequence {a1,a2,...,an} and you can delete a contiguous subsequence of length m. So what is the minimum number of inversions after the deletion.


##### Input
There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:

The first line contains two integers n,m(1≤n≤105,1≤m<n) - the length of the seuqence. The second line contains n integers a1,a2,...,an(1≤ai≤n).

The sum of n in the test cases will not exceed 2×106.


##### Output
For each test case, output the minimum number of inversions.

```cpp
Sample Input
2
3 1
1 2 3
4 2
4 1 3 2


Sample Output
0
1
```

##### Source
BestCoder Round #58 (div.2)


<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月11日 星期日 23时36分50秒
File Name     :HDOJ5497_2.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int maxn=100100;
typedef long long int LL;

LL pref[maxn<<2];
LL suff[maxn<<2];

#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1

void push_up(LL* tree,int rt)
{
	tree[rt]=tree[rt<<1]+tree[rt<<1|1];
}

void build(LL* tree,int l,int r,int rt)
{
	if(l==r) { tree[rt]=0; return ; }
	int m=(l+r)/2;
	build(tree,lson); build(tree,rson);
	push_up(tree,rt);
}

void update(LL* tree,int P,int V,int l,int r,int rt)
{
	if(l==r) { tree[rt]+=V; return ; }

	int m=(l+r)/2;
	if(P<=m) update(tree,P,V,lson);
	if(P>m) update(tree,P,V,rson);

	push_up(tree,rt);
}

LL query(LL* tree,int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R) { return tree[rt]; }

	int m=(l+r)/2;
	LL ret=0;
	if(L<=m) ret+=query(tree,L,R,lson);
	if(R>m) ret+=query(tree,L,R,rson);

	return ret;
}

int n,m;
int a[maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d%d",&n,&m);
		build(suff,0,n+1,1); build(pref,0,n+1,1);
		LL ans,inv=0;
		for(int i=1;i<=n;i++) 
		{
			scanf("%d",a+i);
			if(i>m)
			{
				inv+=query(suff,a[i]+1,n,0,n+1,1);
				update(suff,a[i],1,0,n+1,1);
			}
		}
		ans=inv;

		int L=1,R=m;
		while(R<n)
		{
			/// rm R+1
			int xx=a[R+1];

			/// 减去前缀中比它大的数产生的逆序数
			inv-=query(pref,xx+1,n+1,0,n+1,1);
			/// 在后缀中去掉自己
			update(suff,xx,-1,0,n+1,1);
			/// 减去在后缀中比它小的数产生的逆序数
			inv-=query(suff,0,xx-1,0,n+1,1);

			/// add L+1
			xx=a[L];

			/// 加上前缀中比它大的数产生的逆序数
			inv+=query(pref,xx+1,n+1,0,n+1,1);
			/// 在前缀中加上自己
			update(pref,xx,1,0,n+1,1);
			/// 加上后缀中比它小的数产生的逆序数
			inv+=query(suff,0,xx-1,0,n+1,1);

			ans=min(ans,inv);
			L++; R++;

		}

		printf("%lld\n",ans);
	}
    
    return 0;
}
```
