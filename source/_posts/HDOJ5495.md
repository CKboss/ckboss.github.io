title: HDOJ 5495 LCS 想法
date: 2015-10-03 22:17:43
tags:
- 想法

categories:
- acm_想法

---

题目实际意思是可以把两个数组成对的重新排列....

既然可以重新排列,那么以一个数组不变另一个数组通过调整位置和这个数组逐一匹配就好了....

### [LCS](http://acm.hdu.edu.cn/showproblem.php?pid=5495)

Time Limit: 6000/3000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)
Total Submission(s): 135    Accepted Submission(s): 62


##### Problem Description
You are given two sequence {a1,a2,...,an} and {b1,b2,...,bn}. Both sequences are permutation of {1,2,...,n}. You are going to find another permutation {p1,p2,...,pn} such that the length of LCS (longest common subsequence) of {ap1,ap2,...,apn} and {bp1,bp2,...,bpn} is maximum.


##### Input
There are multiple test cases. The first line of input contains an integer T, indicating the number of test cases. For each test case:

The first line contains an integer n(1≤n≤105) - the length of the permutation. The second line contains n integers a1,a2,...,an. The third line contains n integers b1,b2,...,bn.

The sum of n in the test cases will not exceed 2×106.


##### Output
For each test case, output the maximum length of LCS.

```cpp
Sample Input
2
3
1 2 3
3 2 1
6
1 5 3 2 6 4
3 6 2 4 5 1


Sample Output
2
4
```

##### Source
BestCoder Round #58 (div.2)

<!-- more -->

```cpp
/* ***********************************************
Author        :CKboss
Created Time  :2015年10月03日 星期六 22时03分41秒
File Name     :HDOJ5495.cpp
************************************************ */

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <set>
#include <map>

using namespace std;

const int maxn=110000;

int n;
int a[maxn],b[maxn];
int pos[maxn];
bool used[maxn];

int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);

	int T_T;
	scanf("%d",&T_T);
	while(T_T--)
	{
		scanf("%d",&n);
		for(int i=0;i<n;i++) scanf("%d",a+i);
		for(int i=0;i<n;i++)
		{
			used[i+1]=false; scanf("%d",b+i); pos[b[i]]=i;
		}

		int lcs=0;
		for(int i=0;i<n;i++)
		{
			if(a[i]==b[i]) lcs++;
			else
			{
				if(used[a[i]]==true) continue;
				int j=pos[a[i]];
				pos[b[i+1]]=j;
				swap(a[i+1],a[j]); swap(b[i+1],b[j]);
				lcs++; used[b[i]]=true;
			}
		}
		printf("%d\n",lcs);
	}
    
    return 0;
}
```


